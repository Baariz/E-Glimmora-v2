---
phase: 04-b2b-institutional-portal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/services/config.ts
  - src/lib/hooks/useServices.ts
  - src/lib/types/entities.ts
  - src/lib/types/validation.ts
  - src/lib/services/interfaces/IClientService.ts
  - src/lib/services/interfaces/index.ts
  - src/lib/services/mock/client.mock.ts
  - src/lib/services/mock/risk.mock.ts
  - src/lib/services/mock/contract.mock.ts
  - src/lib/services/mock/audit.mock.ts
  - src/lib/state-machines/journey-workflow.ts
  - src/components/b2b/tables/DataTable.tsx
  - src/components/b2b/layouts/StatsRow.tsx
  - src/components/b2b/layouts/StatusBadge.tsx
  - src/app/(b2b)/layout.tsx
  - src/app/(b2b)/portfolio/page.tsx
autonomous: true

must_haves:
  truths:
    - "B2B pages can fetch client, risk, contract, and audit data from mock services"
    - "Portfolio Dashboard shows real data sections: stats row, risk heat map, journey pipeline, NDA tracker"
    - "DataTable component renders sortable, filterable, paginated data grids"
    - "Journey state machine validates transitions and enforces permissions"
    - "Toast notifications appear for B2B actions via Sonner"
  artifacts:
    - path: "src/lib/services/mock/client.mock.ts"
      provides: "MockClientService with CRUD operations for UHNI client records"
      exports: ["MockClientService"]
    - path: "src/lib/services/mock/risk.mock.ts"
      provides: "MockRiskService with risk record CRUD and portfolio risk queries"
      exports: ["MockRiskService"]
    - path: "src/lib/services/mock/contract.mock.ts"
      provides: "MockContractService with contract and revenue record queries"
      exports: ["MockContractService"]
    - path: "src/lib/services/mock/audit.mock.ts"
      provides: "MockAuditService with append-only audit logging"
      exports: ["MockAuditService"]
    - path: "src/lib/state-machines/journey-workflow.ts"
      provides: "Journey approval state machine with permission-gated transitions"
      exports: ["journeyStateMachine", "getAvailableTransitions", "executeTransition"]
    - path: "src/components/b2b/tables/DataTable.tsx"
      provides: "Reusable TanStack Table wrapper with sorting, filtering, pagination"
      exports: ["DataTable"]
    - path: "src/app/(b2b)/portfolio/page.tsx"
      provides: "Full Portfolio Dashboard with 7 dashboard sections"
      min_lines: 100
  key_links:
    - from: "src/lib/hooks/useServices.ts"
      to: "src/lib/services/mock/client.mock.ts"
      via: "useServices hook returns client service instance"
      pattern: "client:\\s*new MockClientService"
    - from: "src/lib/state-machines/journey-workflow.ts"
      to: "src/lib/rbac/permissions.ts"
      via: "state machine checks hasPermission before transition"
      pattern: "hasPermission"
    - from: "src/app/(b2b)/portfolio/page.tsx"
      to: "src/lib/hooks/useServices.ts"
      via: "portfolio page fetches data from services"
      pattern: "useServices"
---

<objective>
Install Phase 4 dependencies, create B2B mock service layer (client, risk, contract, audit), build journey governance state machine, create reusable DataTable component with TanStack Table, and build the full Portfolio Dashboard with all 7 DASH requirements.

Purpose: Establishes all B2B infrastructure (services, state machine, data table, layout) that every subsequent plan depends on, plus delivers the main dashboard that RMs see on login.

Output: Working Portfolio Dashboard with real mock data, reusable DataTable component, 4 new mock services, journey state machine, Sonner toast integration.
</objective>

<execution_context>
@/Users/kavi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-b2b-institutional-portal/04-RESEARCH.md

Key existing files to reference:
@src/lib/services/mock/base.mock.ts (BaseMockService pattern to follow)
@src/lib/services/mock/journey.mock.ts (mock service implementation pattern)
@src/lib/services/config.ts (service registry to extend)
@src/lib/hooks/useServices.ts (hook to extend with new services)
@src/lib/types/entities.ts (existing entity types — Journey, RiskRecord, Contract, etc.)
@src/lib/types/validation.ts (Zod schemas to extend)
@src/lib/types/roles.ts (B2BRole enum with all 6 roles)
@src/lib/rbac/permissions.ts (hasPermission function, B2B permission matrices)
@src/lib/rbac/usePermission.ts (useCan hook for permission checks)
@src/app/(b2b)/layout.tsx (existing B2B layout with sidebar)
@src/app/(b2b)/portfolio/page.tsx (existing placeholder to replace)
@src/components/shared/Card/index.tsx (Card component pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install deps, create B2B mock services, state machine, and types</name>
  <files>
    package.json
    src/lib/types/entities.ts
    src/lib/types/validation.ts
    src/lib/services/interfaces/IClientService.ts
    src/lib/services/interfaces/index.ts
    src/lib/services/mock/client.mock.ts
    src/lib/services/mock/risk.mock.ts
    src/lib/services/mock/contract.mock.ts
    src/lib/services/mock/audit.mock.ts
    src/lib/services/config.ts
    src/lib/hooks/useServices.ts
    src/lib/state-machines/journey-workflow.ts
  </files>
  <action>
    **Step 1: Install dependencies**
    Run `npm install @tanstack/react-table sonner` in project root.

    **Step 2: Add ClientRecord type and B2B validation schemas**

    In `src/lib/types/entities.ts`, add a `ClientRecord` type (this is the B2B concept of an RM's view of a UHNI client — NOT the same as User):
    ```typescript
    // B2B Client Record (RM's view of a UHNI client)
    export type ClientStatus = 'Active' | 'Pending' | 'Onboarding' | 'Archived';

    export interface ClientRecord {
      id: string;
      userId: string; // Links to User entity
      institutionId: string;
      assignedRM: string; // User ID of the RM
      assignedAdvisors: string[]; // User IDs of advisors
      name: string;
      email: string;
      status: ClientStatus;
      riskCategory: RiskCategory;
      riskScore: number;
      emotionalProfile?: EmotionalDrivers;
      activeJourneyCount: number;
      totalJourneyCount: number;
      ndaStatus: 'Active' | 'Expired' | 'Pending' | 'None';
      ndaExpiresAt?: string;
      lastActivity: string;
      onboardedAt: string;
      createdAt: string;
      updatedAt: string;
    }
    ```

    Also add `InsuranceLog` type:
    ```typescript
    export interface InsuranceLog {
      id: string;
      clientId: string;
      institutionId: string;
      type: string; // e.g., "Travel", "Health", "Property"
      provider: string;
      policyNumber: string;
      coverage: string;
      validFrom: string;
      validUntil: string;
      notes?: string;
      createdBy: string;
      createdAt: string;
      updatedAt: string;
    }
    ```

    Also add `GeopoliticalRisk` and `TravelAdvisory` types:
    ```typescript
    export type ThreatLevel = 'Low' | 'Moderate' | 'Elevated' | 'High' | 'Critical';

    export interface GeopoliticalRisk {
      id: string;
      region: string;
      country: string;
      threatLevel: ThreatLevel;
      riskFactors: string[];
      lastUpdated: string;
    }

    export interface TravelAdvisory {
      id: string;
      country: string;
      region: string;
      advisoryLevel: ThreatLevel;
      summary: string;
      effectiveDate: string;
      expiresAt?: string;
    }
    ```

    Also add `RetentionPolicy` type:
    ```typescript
    export interface RetentionPolicy {
      id: string;
      institutionId: string;
      entityType: string;
      retentionDays: number;
      autoArchive: boolean;
      autoDelete: boolean;
      createdBy: string;
      createdAt: string;
      updatedAt: string;
    }
    ```

    In `src/lib/types/validation.ts`, add `CreateClientRecordSchema`:
    ```typescript
    export const CreateClientRecordSchema = z.object({
      userId: z.string().uuid('Invalid user ID'),
      institutionId: z.string().uuid('Invalid institution ID'),
      assignedRM: z.string().uuid('Invalid RM ID'),
      name: z.string().min(1, 'Name required').max(100, 'Name too long'),
      email: z.string().email('Invalid email'),
    });
    export type CreateClientRecordInput = z.infer<typeof CreateClientRecordSchema>;
    ```

    **Step 3: Create IClientService interface**

    Create `src/lib/services/interfaces/IClientService.ts`:
    ```typescript
    import { ClientRecord, CreateClientRecordInput } from '@/lib/types';

    export interface IClientService {
      getClientsByRM(rmId: string): Promise<ClientRecord[]>;
      getClientsByInstitution(institutionId: string): Promise<ClientRecord[]>;
      getClientById(id: string): Promise<ClientRecord | null>;
      createClient(data: CreateClientRecordInput): Promise<ClientRecord>;
      updateClient(id: string, data: Partial<ClientRecord>): Promise<ClientRecord>;
      assignAdvisor(clientId: string, advisorId: string): Promise<ClientRecord>;
      removeAdvisor(clientId: string, advisorId: string): Promise<ClientRecord>;
      archiveClient(id: string): Promise<ClientRecord>;
    }
    ```

    Add `export * from './IClientService'` to `src/lib/services/interfaces/index.ts`.

    **Step 4: Create MockClientService**

    Create `src/lib/services/mock/client.mock.ts` extending `BaseMockService`. Implements `IClientService`. Storage key: `'clients'`. Seeds 8-10 realistic mock clients with diverse risk categories, statuses, journey counts, NDA statuses. Include seed method that checks if localStorage already has data before seeding (idempotent). Client names should feel UHNI-realistic (e.g., "Arabella Chen-Worthington", "Sebastian Al-Rashid", "Marguerite Van der Berg"). Each client has varying risk scores (20-90), active journey counts (0-5), and mix of statuses.

    **Step 5: Create MockRiskService**

    Create `src/lib/services/mock/risk.mock.ts` extending `BaseMockService`. Implements existing `IRiskService` from interfaces. Storage key: `'risk_records'`. Add seed data matching the mock clients (8-10 risk records). Add `getPortfolioRisk(institutionId: string)` method that returns aggregated risk metrics.

    **Step 6: Create MockContractService**

    Create `src/lib/services/mock/contract.mock.ts` extending `BaseMockService`. Implements existing `IContractService`. Storage keys: `'contracts'`, `'revenue_records'`. Seed with 2-3 contracts and 6-8 revenue records.

    **Step 7: Create MockAuditService**

    Create `src/lib/services/mock/audit.mock.ts` implementing `IAuditService`. Uses `BaseMockService` pattern. Storage key: `'audit_events'`. The `log()` method appends to the array (NEVER deletes — append-only). Seed with 15-20 recent audit events showing diverse actions (CREATE, READ, UPDATE, APPROVE).

    **Step 8: Register new services**

    Update `src/lib/services/config.ts` to import and register MockClientService, MockRiskService, MockContractService, MockAuditService. Add to service registry type assertion.

    Update `src/lib/hooks/useServices.ts` to include client, risk, contract, audit service instances in the returned object.

    **Step 9: Create journey workflow state machine**

    Create `src/lib/state-machines/journey-workflow.ts`. This is a plain TypeScript configuration-driven state machine (NOT XState):

    States: DRAFT, RM_REVIEW, COMPLIANCE_REVIEW, APPROVED, PRESENTED, EXECUTED, ARCHIVED

    Transitions config:
    ```typescript
    const JOURNEY_TRANSITIONS = {
      DRAFT: {
        SUBMIT_FOR_REVIEW: { next: 'RM_REVIEW', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
      },
      RM_REVIEW: {
        APPROVE: { next: 'COMPLIANCE_REVIEW', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
        REQUEST_CHANGES: { next: 'DRAFT', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
      },
      COMPLIANCE_REVIEW: {
        APPROVE: { next: 'APPROVED', requiredPermission: { action: Permission.APPROVE, resource: 'journey' as Resource } },
        REJECT: { next: 'DRAFT', requiredPermission: { action: Permission.APPROVE, resource: 'journey' as Resource } },
      },
      APPROVED: {
        PRESENT_TO_CLIENT: { next: 'PRESENTED', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
      },
      PRESENTED: {
        BEGIN_EXECUTION: { next: 'EXECUTED', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
      },
      EXECUTED: {
        ARCHIVE: { next: 'ARCHIVED', requiredPermission: { action: Permission.WRITE, resource: 'journey' as Resource } },
      },
      ARCHIVED: {},
    }
    ```

    Export functions:
    - `getAvailableTransitions(state: JourneyStatus, role: Role, context: DomainContext): string[]` — returns event names the role can trigger from this state
    - `executeTransition(state: JourneyStatus, event: string, role: Role, context: DomainContext): JourneyStatus` — validates and returns next state, throws if invalid
    - `getTransitionLabel(event: string): string` — human-readable labels for UI buttons
    - `getStateLabel(state: JourneyStatus): string` — human-readable state names
    - `getStateColor(state: JourneyStatus): string` — Tailwind color class per state (e.g., DRAFT = slate, APPROVED = teal, etc.)

    Use `hasPermission` from `@/lib/rbac/permissions` for permission checks.
  </action>
  <verify>
    Run `npm run build` (or `npx next build`) and confirm no TypeScript errors. Verify the new files exist:
    - `ls src/lib/services/mock/client.mock.ts src/lib/services/mock/risk.mock.ts src/lib/services/mock/contract.mock.ts src/lib/services/mock/audit.mock.ts`
    - `ls src/lib/state-machines/journey-workflow.ts`
    - Check `package.json` includes `@tanstack/react-table` and `sonner`
  </verify>
  <done>
    All 4 mock services created and registered in config + useServices hook. Journey state machine exports transition functions. @tanstack/react-table and sonner installed. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build DataTable component, B2B layout upgrade, and full Portfolio Dashboard</name>
  <files>
    src/components/b2b/tables/DataTable.tsx
    src/components/b2b/layouts/StatsRow.tsx
    src/components/b2b/layouts/StatusBadge.tsx
    src/app/(b2b)/layout.tsx
    src/app/(b2b)/portfolio/page.tsx
  </files>
  <action>
    **Step 1: Create reusable DataTable component**

    Create `src/components/b2b/tables/DataTable.tsx` — a wrapper around TanStack Table that all B2B pages reuse.

    Props interface:
    ```typescript
    interface DataTableProps<TData> {
      columns: ColumnDef<TData, any>[];
      data: TData[];
      searchPlaceholder?: string;
      searchColumn?: string; // Column key to filter on
      pageSize?: number; // Default 25
      onRowClick?: (row: TData) => void;
      emptyMessage?: string;
    }
    ```

    Features:
    - `getCoreRowModel`, `getSortedRowModel`, `getFilteredRowModel`, `getPaginationRowModel` from TanStack
    - Global filter input at top (optional, controlled by searchColumn prop)
    - Column headers clickable for sorting with sort indicator arrows
    - Pagination controls at bottom (Previous/Next, page X of Y, page size selector: 10/25/50)
    - Row hover state (`hover:bg-slate-50`)
    - Optional row click handler for navigation
    - Empty state with emptyMessage when no data
    - Styling: Use luxury B2B aesthetic (font-sans, slate palette, clean dividers, subtle shadows). Table header text-xs uppercase tracking-wider. No borders on outer edge (clean look).

    **Step 2: Create StatsRow component**

    Create `src/components/b2b/layouts/StatsRow.tsx`:
    ```typescript
    interface StatCard {
      label: string;
      value: string | number;
      subtitle?: string;
      trend?: { value: string; positive: boolean };
      colorClass?: string; // e.g., 'from-white to-rose-50'
    }

    interface StatsRowProps {
      stats: StatCard[];
    }
    ```

    Renders a responsive grid (grid-cols-1 md:grid-cols-2 lg:grid-cols-4) of stat cards using the existing Card component. Each card shows label (text-sm text-slate-600), value (text-3xl font-serif), subtitle (text-xs text-slate-500), optional trend indicator (green/red arrow).

    **Step 3: Create StatusBadge component**

    Create `src/components/b2b/layouts/StatusBadge.tsx`:
    A generic badge component for rendering status values with color coding.
    ```typescript
    interface StatusBadgeProps {
      status: string;
      colorMap?: Record<string, string>; // status -> tailwind classes
      size?: 'sm' | 'md';
    }
    ```
    Default color map covers common statuses: Active=teal, Pending=gold, Archived=slate, Draft=slate, Approved=olive, etc. Renders as `inline-flex px-2 py-1 text-xs font-sans rounded-full`.

    **Step 4: Upgrade B2B layout with Sonner**

    Update `src/app/(b2b)/layout.tsx`:
    - Add `import { Toaster } from 'sonner'`
    - Add `<Toaster position="top-right" richColors />` inside the layout
    - Add `'use client'` directive (needed for Sonner)
    - Keep all existing sidebar nav and structure

    **Step 5: Build full Portfolio Dashboard**

    Replace `src/app/(b2b)/portfolio/page.tsx` placeholder with the complete dashboard. Mark it `'use client'`.

    Use a hardcoded `MOCK_RM_USER_ID` (a UUID constant like `'b2b-rm-001-uuid-placeholder'`) and `MOCK_INSTITUTION_ID` (similar pattern) for development, matching the pattern from B2C's `MOCK_UHNI_USER_ID`.

    Dashboard sections (all 7 DASH requirements):

    1. **Stats Row** (DASH-01 partial, DASH-07): Use StatsRow component showing Total Clients, Active Journeys, Risk Alerts (count of High/Critical), Quarterly Revenue. Fetch from client, journey, risk, contract services.

    2. **Portfolio Client Table** (DASH-01): DataTable showing all RM's clients with columns: Client Name, Status (StatusBadge), Risk (StatusBadge with risk colors), Active Journeys, NDA Status, Last Activity (formatted with date-fns `formatDistanceToNow`). Row click navigates to `/clients/{id}`. Search on client name.

    3. **Risk Heat Map** (DASH-02): Use Recharts ScatterChart with colored cells. X-axis = client index (hidden), Y-axis = risk score 0-100. Cell color based on riskCategory (Low=olive, Medium=gold, High=rose, Critical=red-600). Custom tooltip showing client name + risk category + score.

    4. **Journey Pipeline Tracker** (DASH-03): Horizontal visual showing journey counts per status (DRAFT, RM_REVIEW, COMPLIANCE_REVIEW, APPROVED, PRESENTED, EXECUTED). Use colored bars or segments. Show count in each segment. Fetch all journeys for the RM's clients and group by status.

    5. **Emotional Insight Comparison** (DASH-04): Grid of compact client emotional profile cards (3 columns on lg). Each card shows client name and a small Recharts RadarChart of their EmotionalDrivers (reuse the pattern from B2C briefing's BalanceSummary). Only show clients that have an emotionalProfile set.

    6. **NDA Tracker** (DASH-05) + **Compliance Alerts** (DASH-06): Combined section. NDA section: small table showing clients with NDAs, their status (Active/Expired/Pending), and expiry date. Compliance alerts: list of flagged items — clients with risk category High/Critical, expired NDAs, journeys stuck in COMPLIANCE_REVIEW for >7 days. Show alert count badge.

    7. **Revenue Metrics** (DASH-07): Use Recharts BarChart showing revenue by month (last 6 months from mock data). Below chart, show summary: total revenue, average per client, billing overview table.

    Each section wrapped in Card component with header. Loading states with skeleton shimmer while services fetch data. Use `useEffect` to load data on mount from services via `useServices()`.

    Use `useCan()` hook to conditionally render sections:
    - Risk heat map: `can(Permission.READ, 'risk')`
    - Revenue metrics: `can(Permission.READ, 'revenue')` (RM doesn't see this by default, but PrivateBanker does)
    - Journey pipeline: `can(Permission.READ, 'journey')`

    Import `toast` from `sonner` for any error states (e.g., `toast.error('Failed to load portfolio data')`).
  </action>
  <verify>
    Run `npm run build` and confirm no TypeScript errors. Run `npm run dev` and verify:
    - Navigate to `/portfolio` — should see full dashboard with stats, tables, charts
    - DataTable should have working sort (click column headers), search, pagination
    - Risk heat map should render colored dots
    - Journey pipeline should show status counts
    - Sonner toaster should be visible in layout
  </verify>
  <done>
    Portfolio Dashboard renders all 7 DASH sections with real mock data. DataTable component works with sorting, filtering, pagination. StatsRow and StatusBadge are reusable. Sonner integrated in B2B layout. All sections respect RBAC permissions via useCan().
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- Portfolio Dashboard at `/portfolio` shows all 7 sections (stats, client table, risk heat map, journey pipeline, emotional insights, NDA/compliance, revenue)
- DataTable sorting works (click column headers, arrow indicator changes)
- DataTable pagination works (navigate between pages, change page size)
- Risk heat map shows colored scatter dots with tooltips
- Journey pipeline shows status distribution
- New mock services seeded with realistic data on first load
- State machine correctly validates transitions (e.g., DRAFT -> RM_REVIEW valid, DRAFT -> APPROVED invalid)
</verification>

<success_criteria>
All 7 DASH requirements (DASH-01 through DASH-07) are visually present on the Portfolio Dashboard. The DataTable, StatsRow, StatusBadge, and state machine are reusable foundations for subsequent plans. Four new mock services (client, risk, contract, audit) are registered and seeded. Sonner toasts appear on errors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-b2b-institutional-portal/04-01-SUMMARY.md`
</output>
