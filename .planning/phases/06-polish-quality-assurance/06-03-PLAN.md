---
phase: 06-polish-quality-assurance
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - vitest.config.mts
  - playwright.config.ts
  - src/tests/unit/rbac-permissions.test.ts
  - src/tests/unit/service-contracts.test.ts
  - src/tests/unit/cascade-deletion.test.ts
  - src/tests/e2e/b2c-intake-journey.spec.ts
  - src/tests/e2e/b2b-onboarding-governance.spec.ts
  - src/tests/e2e/admin-invite-member.spec.ts
  - src/tests/visual/design-system.spec.ts
  - src/components/shared/Button/Button.tsx
  - src/components/shared/Card/Card.tsx
  - src/components/shared/Input/Input.tsx
  - src/components/shared/Modal/Modal.tsx
  - src/app/(b2c)/layout.tsx
  - src/app/(b2b)/layout.tsx
  - src/app/(admin)/layout.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "ARIA labels, keyboard navigation, and screen reader support implemented across shared UI components"
    - "WCAG AA compliance (4.5:1 minimum) for color contrast on primary interactive elements, with AAA (7:1) where the luxury palette allows — verified by contrast ratio audit"
    - "Focus indicators visible with rose-500 ring on all focusable elements"
    - "Vitest unit tests cover RBAC permission resolution for all 11 roles across 3 domains"
    - "Vitest unit tests cover dual-context users with B2C and B2B role combinations"
    - "Vitest unit tests cover cascade deletion logic in memory and journey mock services"
    - "Playwright E2E tests cover B2C intake to journey generation critical path"
    - "Playwright E2E tests cover B2B client onboarding to governance approval critical path"
    - "Playwright E2E tests cover Admin invite generation to member activation critical path"
    - "Visual regression tests exist for design system components (Button, Card, Input, Modal)"
  artifacts:
    - path: "vitest.config.mts"
      provides: "Vitest configuration with React plugin and path aliases"
      contains: "react"
    - path: "playwright.config.ts"
      provides: "Playwright configuration with webServer and visual regression settings"
      contains: "webServer"
    - path: "src/tests/unit/rbac-permissions.test.ts"
      provides: "Unit tests for RBAC permission resolution across all 11 roles"
      contains: "hasPermission"
    - path: "src/tests/unit/cascade-deletion.test.ts"
      provides: "Unit tests for cascade delete logic in mock services"
      contains: "delete"
    - path: "src/tests/e2e/b2c-intake-journey.spec.ts"
      provides: "E2E test for B2C intake wizard to journey generation flow"
      contains: "intake"
    - path: "src/tests/e2e/b2b-onboarding-governance.spec.ts"
      provides: "E2E test for B2B client onboarding to governance approval"
      contains: "governance"
    - path: "src/tests/e2e/admin-invite-member.spec.ts"
      provides: "E2E test for admin invite generation to member activation"
      contains: "invite"
  key_links:
    - from: "src/tests/unit/rbac-permissions.test.ts"
      to: "src/lib/rbac/permissions.ts"
      via: "Import hasPermission for testing"
      pattern: "import.*hasPermission.*permissions"
    - from: "src/tests/unit/cascade-deletion.test.ts"
      to: "src/lib/services/mock"
      via: "Import mock services for cascade testing"
      pattern: "import.*MockMemoryService|MockJourneyService"
    - from: "vitest.config.mts"
      to: "tsconfig.json"
      via: "Path alias resolution"
      pattern: "tsconfigPaths|resolve.*alias"
---

<objective>
Implement accessibility compliance across shared UI components and build comprehensive testing infrastructure covering RBAC unit tests, E2E critical paths, and visual regression baselines.

Purpose: Accessibility ensures UHNI can use the platform regardless of ability — WCAG compliance is both ethical and legal. Testing provides confidence that all 116 requirements continue working as the platform evolves.

Output: ARIA-enhanced UI components, Vitest unit test suite (RBAC, services, cascade), Playwright E2E tests (3 critical paths), and visual regression baseline.
</objective>

<execution_context>
@/Users/kavi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-quality-assurance/06-RESEARCH.md

# RBAC system to test
@src/lib/rbac/permissions.ts
@src/lib/rbac/filters.ts
@src/lib/rbac/index.ts
@src/lib/types/roles.ts
@src/lib/types/permissions.ts

# Services to test
@src/lib/services/mock/memory.mock.ts
@src/lib/services/mock/journey.mock.ts
@src/lib/services/mock/base.mock.ts

# UI components to enhance with accessibility
@src/components/shared/Button/Button.tsx
@src/components/shared/Card/Card.tsx
@src/components/shared/Input/Input.tsx
@src/components/shared/Modal/Modal.tsx
@src/components/shared/index.ts

# Layouts for ARIA landmarks
@src/app/(b2c)/layout.tsx
@src/app/(b2b)/layout.tsx
@src/app/(admin)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install testing infrastructure, configure Vitest and Playwright, enhance component accessibility</name>
  <files>
    vitest.config.mts
    playwright.config.ts
    package.json
    src/components/shared/Button/Button.tsx
    src/components/shared/Card/Card.tsx
    src/components/shared/Input/Input.tsx
    src/components/shared/Modal/Modal.tsx
    src/app/(b2c)/layout.tsx
    src/app/(b2b)/layout.tsx
    src/app/(admin)/layout.tsx
  </files>
  <action>
  1. Install testing dependencies:
     ```bash
     npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
     npm install -D @playwright/test
     npx playwright install chromium
     ```

  2. Create `vitest.config.mts`:
     ```typescript
     import { defineConfig } from 'vitest/config'
     import react from '@vitejs/plugin-react'
     import tsconfigPaths from 'vite-tsconfig-paths'

     export default defineConfig({
       plugins: [react(), tsconfigPaths()],
       test: {
         environment: 'jsdom',
         globals: true,
         include: ['src/tests/unit/**/*.test.ts', 'src/tests/unit/**/*.test.tsx'],
         setupFiles: ['./src/tests/setup.ts'],
         coverage: {
           provider: 'v8',
           include: ['src/lib/rbac/**', 'src/lib/services/**'],
         },
       },
     })
     ```

  3. Create `src/tests/setup.ts`:
     - Import `@testing-library/jest-dom` if needed
     - Create localStorage mock for jsdom environment:
       ```typescript
       const localStorageMock = {
         store: {} as Record<string, string>,
         getItem: (key: string) => localStorageMock.store[key] || null,
         setItem: (key: string, value: string) => { localStorageMock.store[key] = value },
         removeItem: (key: string) => { delete localStorageMock.store[key] },
         clear: () => { localStorageMock.store = {} },
         get length() { return Object.keys(localStorageMock.store).length },
         key: (index: number) => Object.keys(localStorageMock.store)[index] || null,
       }
       Object.defineProperty(globalThis, 'localStorage', { value: localStorageMock })
       ```

  4. Create `playwright.config.ts`:
     ```typescript
     import { defineConfig, devices } from '@playwright/test'

     export default defineConfig({
       testDir: './src/tests',
       testMatch: ['**/*.spec.ts'],
       fullyParallel: true,
       forbidOnly: !!process.env.CI,
       retries: process.env.CI ? 2 : 0,
       workers: process.env.CI ? 1 : undefined,
       reporter: 'html',
       use: {
         baseURL: 'http://localhost:3000',
         trace: 'on-first-retry',
       },
       projects: [
         { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
         { name: 'mobile-chrome', use: { ...devices['Pixel 5'] } },
       ],
       webServer: {
         command: 'npm run build && npm run start',
         url: 'http://localhost:3000',
         reuseExistingServer: !process.env.CI,
         timeout: 120000,
       },
     })
     ```

  5. Add test scripts to `package.json`:
     - `"test": "vitest"` — run unit tests
     - `"test:unit": "vitest run"` — run unit tests once
     - `"test:e2e": "playwright test"` — run E2E tests
     - `"test:visual": "playwright test --project=chromium src/tests/visual"` — run visual regression tests

  6. Enhance shared UI component accessibility:

     **Button.tsx** (read first, then enhance):
     - Ensure `aria-disabled` is set when disabled (in addition to HTML disabled attribute)
     - Ensure `role="button"` is implicit (native button element provides this)
     - Add `aria-busy={loading}` when loading prop is true (may already be done in 06-01)
     - Verify `focus-visible:ring-2 focus-visible:ring-rose-500 focus-visible:ring-offset-2` classes exist

     **Card.tsx** (read first, then enhance):
     - Add `role="region"` for semantic cards with content sections
     - Add optional `aria-label` prop for screen reader context
     - Ensure interactive cards have `tabIndex={0}` and `role="article"` or `role="button"` as appropriate

     **Input.tsx** (read first, then enhance):
     - Add `aria-invalid={!!error}` when error state is present
     - Add `aria-describedby` pointing to error message element when error is shown
     - Add `aria-required={required}` for required fields
     - Ensure label element has `htmlFor` matching input `id`
     - Ensure `focus-visible:ring-2 focus-visible:ring-rose-500` classes exist

     **Modal.tsx** (read first, then enhance):
     - Radix Dialog already provides accessibility — verify:
       - `aria-modal="true"` is set (Radix does this automatically)
       - Focus trap works (Radix provides this)
       - `aria-labelledby` points to title element
       - `aria-describedby` points to description element
       - ESC key closes modal (Radix provides this)
     - If custom modal (not Radix), add these manually

  7. Add ARIA landmarks to layouts:
     - B2C layout: `<nav aria-label="B2C navigation">`, `<main aria-label="B2C content">`
     - B2B layout: `<nav aria-label="B2B sidebar navigation">`, `<main aria-label="B2B dashboard content">`
     - Admin layout: `<nav aria-label="Admin navigation">`, `<main aria-label="Admin content">`
     - These are quick additions to existing elements (add `aria-label` attribute to existing `<nav>` and `<main>` tags)

  8. Audit and fix color contrast ratios for WCAG compliance:
     - Read the Tailwind theme config (`tailwind.config.ts`) and identify all luxury palette colors used on interactive elements (buttons, links, inputs, focus rings).
     - For each foreground/background pairing on primary interactive elements, compute the contrast ratio:
       - **WCAG AA minimum (mandatory):** 4.5:1 for normal text, 3:1 for large text (18px+ or 14px+ bold)
       - **WCAG AAA target (where palette allows):** 7:1 for normal text, 4.5:1 for large text
     - Check these specific pairings at minimum:
       - Button text vs button background (all variants: primary, secondary, outline, ghost)
       - Input text vs input background
       - Error text (rose-500) vs background
       - Focus ring (rose-500) vs surrounding background
       - Link text vs background in nav elements
     - Fix any pairing that fails AA (4.5:1). For pairings that pass AA but fail AAA, attempt to adjust shade (e.g., rose-600 instead of rose-500) only if it preserves the luxury aesthetic. Document any AAA exceptions where the palette genuinely cannot reach 7:1.
     - Verification: After fixes, list each checked pairing with its contrast ratio in a code comment at the top of the relevant component or in `src/tests/setup.ts` as a reference table.
  </action>
  <verify>
  - `npx vitest run --passWithNoTests` succeeds (config valid, no tests yet = pass)
  - `npx tsc --noEmit` passes with no type errors on updated components
  - `npm run build` succeeds
  - Playwright config exists at `playwright.config.ts`
  - Test scripts exist in package.json
  </verify>
  <done>
  Vitest configured with jsdom, localStorage mock, and path aliases. Playwright configured with webServer, chromium + mobile-chrome projects, and visual regression support. Shared UI components enhanced with ARIA labels, aria-invalid/describedby/required on inputs, and focus-visible indicators. Layout nav and main elements have aria-label landmarks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Vitest unit tests for RBAC, service contracts, and cascade deletion</name>
  <files>
    src/tests/unit/rbac-permissions.test.ts
    src/tests/unit/service-contracts.test.ts
    src/tests/unit/cascade-deletion.test.ts
  </files>
  <action>
  1. Create `src/tests/unit/rbac-permissions.test.ts`:
     Test the `hasPermission` function from `@/lib/rbac/permissions` with comprehensive coverage:

     **B2C role tests (4 roles x key resources):**
     - UHNI: has READ/WRITE/DELETE/EXPORT on journey, vault, intent, privacy; has CONFIGURE on privacy
     - Spouse: has READ on journey and vault; does NOT have WRITE/DELETE on journey
     - LegacyHeir: has READ on journey and vault; does NOT have WRITE on anything
     - ElanAdvisor: has READ on journey and intent; has READ/WRITE on message; does NOT have WRITE on journey

     **B2B role tests (6 roles x key resources):**
     - RelationshipManager: has READ/WRITE on client and journey; has ASSIGN on client; does NOT have APPROVE on journey
     - PrivateBanker: has READ on client/journey/risk/audit/revenue; does NOT have WRITE on client
     - FamilyOfficeDirector: has CONFIGURE on institution; has READ on client
     - ComplianceOfficer: has APPROVE on journey; has EXPORT on audit; does NOT have WRITE on client
     - InstitutionalAdmin: has CONFIGURE on institution and privacy; has WRITE on user and contract
     - UHNIPortal: has READ on journey and client; does NOT have WRITE on anything

     **Admin role tests:**
     - SuperAdmin: has READ/WRITE/DELETE on invite; has CONFIGURE on institution; has READ on audit/revenue

     **Edge cases:**
     - Unknown role returns false for all permissions
     - Valid role with non-existent resource returns false
     - Context mismatch: B2C role in B2B context returns false (e.g., UHNI checking B2B permissions)

     **Dual-context user tests:**
     - Test `hasPermission` with B2C role in B2C context + same user's B2B role in B2B context
     - User with UHNI (B2C) + RelationshipManager (B2B): B2C context grants journey WRITE, B2B context grants client WRITE
     - Each context's permissions are isolated — B2C role cannot access B2B resources and vice versa

     Also test `filterJourneysByAccess` and `filterMemoriesByAccess` from `@/lib/rbac/filters`:
     - UHNI sees all own journeys
     - Spouse does NOT see invisible journeys
     - LegacyHeir does NOT see invisible journeys
     - UHNI sees all own memories
     - Spouse sees only memories with 'spouse' sharing permission
     - LegacyHeir sees shared memories that are NOT locked

  2. Create `src/tests/unit/service-contracts.test.ts`:
     Test mock service implementations against interface contracts:

     Read `src/lib/services/mock/memory.mock.ts` and `src/lib/services/mock/journey.mock.ts` first.

     **MockMemoryService tests:**
     - `createMemory` returns a MemoryItem with generated id, timestamps
     - `getMemories` returns memories filtered by userId
     - `getMemoryById` returns the correct memory or null
     - `updateMemory` modifies the memory and returns updated version
     - `deleteMemory` removes the memory and returns true

     **MockJourneyService tests:**
     - `createJourney` returns a Journey with generated id
     - `getJourneys` returns journeys filtered by userId
     - `getJourneyById` returns correct journey or null
     - `updateJourney` modifies and returns updated journey
     - `deleteJourney` removes the journey

     For each service: test that data persists across calls (create then retrieve).
     Note: These mock services use localStorage — the test setup file provides the localStorage mock.

  3. Create `src/tests/unit/cascade-deletion.test.ts`:
     Test cascade deletion behavior:

     Read the mock service implementations to understand existing delete logic.

     **Memory cascade tests:**
     - Deleting a memory item removes associated audit logs (if the memory service cascades)
     - Global erase (from privacy service) clears all user data from localStorage
     - Read `src/lib/services/mock/privacy.mock.ts` to understand the `executeGlobalErase` implementation

     **Journey cascade tests:**
     - Deleting a journey should cascade to related messages/threads (check if implemented)
     - If cascade isn't implemented in mock services, test that the delete function at minimum removes the primary entity, and document the gap

     **Global erase tests:**
     - `executeGlobalErase` clears ALL localStorage keys for the user
     - After global erase, `getMemories`, `getJourneys`, `getMessages` return empty arrays for that user
     - After global erase, intent profile is null for that user

     Note: Read the actual service implementations before writing tests. The tests should match the actual behavior, not assumed behavior. If a cascade isn't implemented, test what IS implemented and note gaps.
  </action>
  <verify>
  - `npx vitest run` passes all tests
  - RBAC tests: At least 30 test cases covering all 11 roles and edge cases
  - Service tests: At least 10 test cases covering CRUD operations
  - Cascade tests: At least 5 test cases covering deletion cascades and global erase
  </verify>
  <done>
  RBAC unit tests cover all 11 roles with positive and negative permission checks, dual-context isolation, and data access filters. Service contract tests verify mock implementations fulfill interface contracts. Cascade deletion tests verify global erase clears all user data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write Playwright E2E tests for critical paths and visual regression baseline</name>
  <files>
    src/tests/e2e/b2c-intake-journey.spec.ts
    src/tests/e2e/b2b-onboarding-governance.spec.ts
    src/tests/e2e/admin-invite-member.spec.ts
    src/tests/visual/design-system.spec.ts
  </files>
  <action>
  1. Create `src/tests/e2e/b2c-intake-journey.spec.ts`:
     Test the B2C intake wizard to journey generation critical path.

     **IMPORTANT:** Read the actual intake wizard page first (`src/app/(b2c)/intent/page.tsx`) to understand the real form fields, button labels, and navigation flow. Do NOT assume form field labels — use actual labels from the component.

     Test flow:
     - Navigate to `/intent` (or the correct intake URL)
     - Complete each step of the multi-step wizard by selecting options and clicking Next
     - Submit the final step
     - Verify navigation to journeys page or intent profile page
     - Verify journey cards are visible (if journey generation happens automatically) or intent profile is displayed
     - Use `page.getByRole()` and `page.getByText()` selectors for resilient tests
     - Add `await page.waitForLoadState('networkidle')` after navigation steps

     Note: Since this is mock data, the flow should complete without API calls. The mock service layer handles everything client-side.

  2. Create `src/tests/e2e/b2b-onboarding-governance.spec.ts`:
     Test the B2B client onboarding to governance approval flow.

     Read the actual pages first:
     - Client list page (`src/app/(b2b)/clients/page.tsx`)
     - Governance page (`src/app/(b2b)/governance/page.tsx`)

     Test flow:
     - Navigate to `/clients`
     - Click "Create Client" or "Onboard Client" button
     - Fill the onboarding wizard steps
     - Verify client appears in list
     - Navigate to `/governance`
     - Verify governance pipeline is accessible
     - Verify state machine workflow elements are visible (Draft/Review/Approved states)

  3. Create `src/tests/e2e/admin-invite-member.spec.ts`:
     Test admin invite generation to member activation.

     Read the actual admin pages first:
     - Dashboard (`src/app/(admin)/dashboard/page.tsx`)
     - Invites page (`src/app/(admin)/invites/page.tsx`)
     - Members page (`src/app/(admin)/members/page.tsx`)

     Test flow:
     - Navigate to `/dashboard`
     - Navigate to `/invites`
     - Click "Generate Invite" button
     - Fill invite generation form
     - Verify new invite code appears in table
     - Navigate to `/members`
     - Verify members page loads and displays member list

  4. Create `src/tests/visual/design-system.spec.ts`:
     Visual regression baseline for design system components.

     ```typescript
     import { test, expect } from '@playwright/test'

     test.describe('Design System Visual Regression', () => {
       test('marketing homepage', async ({ page }) => {
         await page.goto('/')
         await page.waitForLoadState('networkidle')
         await expect(page).toHaveScreenshot('homepage.png', {
           fullPage: true,
           animations: 'disabled',
         })
       })

       test('B2C briefing page', async ({ page }) => {
         await page.goto('/briefing')
         await page.waitForLoadState('networkidle')
         await expect(page).toHaveScreenshot('b2c-briefing.png', {
           fullPage: true,
           animations: 'disabled',
         })
       })

       // Add 2-3 more critical pages
     })
     ```

     **Note:** First run will FAIL because no baseline exists. This is expected. Run `npx playwright test --update-snapshots` to create baseline screenshots. Document this in the test file comments.

  **For ALL E2E tests:**
  - Read the actual page components before writing selectors
  - Use semantic selectors: `getByRole('button', { name: '...' })`, `getByText('...')`, `getByLabel('...')`
  - Do NOT use `data-testid` selectors unless elements lack semantic roles
  - Handle auth: The app uses NextAuth — E2E tests may need to mock auth or bypass login. Check if the app redirects unauthenticated users. If it does, add a `test.beforeEach` that sets up auth cookies/session or configure Playwright `storageState`.
  - If auth blocking is complex, create a test helper that sets localStorage auth state matching the mock auth provider pattern.
  </action>
  <verify>
  - `npx vitest run` — all unit tests pass
  - `npx playwright test --project=chromium src/tests/e2e` — E2E tests pass (or document auth-gated tests that need setup)
  - Visual regression baseline setup (two-step process):
    1. **First run — create baselines:** `npx playwright test --update-snapshots --project=chromium src/tests/visual` — this creates the initial `.png` baseline screenshots under the test-results snapshots directory. The first run is expected to "pass" because `--update-snapshots` accepts all screenshots as new baselines.
    2. **Second run — verify against baselines:** `npx playwright test --project=chromium src/tests/visual` — this runs WITHOUT `--update-snapshots` and compares current screenshots against the baselines created in step 1. Tests pass if screenshots match baselines within default threshold. This second run is the actual verification that the baseline system works.
  - Test output shows coverage of all 3 critical paths
  </verify>
  <done>
  E2E tests cover 3 critical paths: B2C intake to journey, B2B onboarding to governance, Admin invite to member. Visual regression baselines established for homepage and key pages. All tests use semantic selectors and handle the mock auth flow. Vitest + Playwright testing infrastructure is fully operational.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all unit tests pass (30+ RBAC, 10+ service, 5+ cascade)
2. `npx playwright test --project=chromium` — E2E tests execute (may need auth setup documented)
3. `npx tsc --noEmit` — no type errors
4. `npm run build` — production build succeeds
5. ARIA check: shared Button, Card, Input, Modal have proper ARIA attributes
6. Focus check: Tab through B2C nav — all links get visible focus ring (rose-500)
7. Keyboard check: Modal opens/closes with keyboard, ESC dismisses
</verification>

<success_criteria>
- Vitest unit tests pass for RBAC permission resolution across all 11 roles with edge cases
- Vitest unit tests pass for service layer CRUD contracts
- Vitest unit tests pass for cascade deletion logic
- Playwright E2E tests cover B2C intake -> journey, B2B onboarding -> governance, Admin invite -> member
- Visual regression baselines established for design system components
- Shared UI components have proper ARIA labels, keyboard support, and focus indicators
- Layout nav/main elements have aria-label landmarks
- Test scripts in package.json: test, test:unit, test:e2e, test:visual
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-quality-assurance/06-03-SUMMARY.md`
</output>
