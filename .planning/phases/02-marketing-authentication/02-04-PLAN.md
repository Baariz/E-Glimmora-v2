---
phase: 02-marketing-authentication
plan: 04
type: execute
wave: 2
depends_on: ["02-03"]
files_modified:
  - src/lib/auth/mfa.ts
  - src/lib/auth/device-recognition.ts
  - src/app/api/auth/mfa/setup/route.ts
  - src/app/api/auth/mfa/verify/route.ts
  - src/app/api/auth/devices/route.ts
  - src/app/api/auth/devices/[id]/route.ts
  - src/app/(marketing)/invite/register/mfa/page.tsx
  - src/components/auth/MFASetup.tsx
  - src/components/auth/MFAVerify.tsx
  - src/components/auth/DeviceManager.tsx
  - src/components/auth/ContextSwitcher.tsx
  - src/lib/services/mock/device.mock.ts
  - src/lib/services/interfaces/IDeviceService.ts
  - src/lib/services/config.ts
  - src/lib/services/index.ts
  - src/auth.ts
  - src/auth.config.ts
  - src/auth.d.ts
autonomous: true

must_haves:
  truths:
    - "User can set up MFA during onboarding with TOTP authenticator app"
    - "User can skip MFA setup during onboarding with a Set up later option"
    - "User with MFA enabled is prompted for TOTP code on login"
    - "User can view list of trusted devices with device name and last used date"
    - "User can revoke a trusted device"
    - "User can switch between B2C and B2B contexts when they have roles in both"
    - "Context switching updates the visible role and navigation context"
  artifacts:
    - path: "src/lib/auth/mfa.ts"
      provides: "TOTP generation and verification"
      min_lines: 30
    - path: "src/lib/auth/device-recognition.ts"
      provides: "Device token management"
      min_lines: 30
    - path: "src/app/api/auth/mfa/setup/route.ts"
      provides: "MFA setup API endpoint"
      min_lines: 20
    - path: "src/app/api/auth/mfa/verify/route.ts"
      provides: "MFA verification API endpoint"
      min_lines: 20
    - path: "src/app/(marketing)/invite/register/mfa/page.tsx"
      provides: "MFA setup page in onboarding flow"
      min_lines: 80
    - path: "src/components/auth/MFASetup.tsx"
      provides: "MFA setup component with QR code display"
      min_lines: 60
    - path: "src/components/auth/DeviceManager.tsx"
      provides: "Trusted device list and revoke UI"
      min_lines: 60
    - path: "src/components/auth/ContextSwitcher.tsx"
      provides: "B2C/B2B context switching component"
      min_lines: 40
    - path: "src/lib/services/mock/device.mock.ts"
      provides: "Mock device service with localStorage"
      min_lines: 50
  key_links:
    - from: "src/lib/auth/mfa.ts"
      to: "otpauth library"
      via: "TOTP generation and verification"
      pattern: "import.*OTPAuth|new OTPAuth\\.TOTP"
    - from: "src/app/api/auth/mfa/setup/route.ts"
      to: "src/lib/auth/mfa.ts"
      via: "generateMFASecret call"
      pattern: "generateMFASecret"
    - from: "src/app/api/auth/mfa/verify/route.ts"
      to: "src/lib/auth/mfa.ts"
      via: "verifyMFAToken call"
      pattern: "verifyMFAToken"
    - from: "src/components/auth/ContextSwitcher.tsx"
      to: "src/lib/hooks/useAuth.ts"
      via: "useAuth().setContext for domain switching"
      pattern: "useAuth|setContext"
    - from: "src/auth.ts"
      to: "MFA verification in login flow"
      via: "authorize callback sets mfaVerified flag, JWT callback handles update trigger"
      pattern: "mfaVerified|mfaEnabled|trigger.*update"
    - from: "src/auth.config.ts"
      to: "/auth/verify-mfa"
      via: "middleware authorized callback redirects when mfaEnabled && !mfaVerified"
      pattern: "mfaVerified|mfaEnabled|verify-mfa"
---

<objective>
Implement MFA setup and verification, device recognition with trusted device management, and B2C/B2B context switching for multi-role users.

Purpose: Complete the authentication layer with security features (MFA, device trust) and role management (context switching). MFA protects UHNI accounts with a second factor. Device recognition allows users to skip MFA on trusted devices. Context switching lets dual-role users (e.g., UHNI who is also a B2B user) move between experiences.

Output: MFA setup/verify flow, trusted device management, context switcher component, and updated auth flow to support MFA during login.
</objective>

<execution_context>
@/Users/kavi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-marketing-authentication/02-RESEARCH.md
@.planning/phases/02-marketing-authentication/02-03-SUMMARY.md

Key existing infrastructure (from 02-03):
- NextAuth v5 configured at src/auth.ts with Credentials provider and JWT sessions
- auth.config.ts with edge-compatible config
- middleware.ts protecting authenticated routes
- auth.d.ts with User/Session/JWT type extensions
- Password utilities at src/lib/auth/password.ts
- Invite code validation at src/lib/auth/invite-codes.ts
- Registration page at src/app/(marketing)/invite/register/page.tsx
- AuthProvider with SessionProvider + DomainContext at src/components/providers/AuthProvider.tsx
- useAuth hook at src/lib/hooks/useAuth.ts
- Service registry with inviteCode service
- otpauth library already installed (from 02-03)
- User entity type has no mfaSecret/mfaEnabled fields yet -- need to add
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MFA with TOTP and device recognition infrastructure</name>
  <files>
    src/lib/auth/mfa.ts
    src/lib/auth/device-recognition.ts
    src/lib/services/interfaces/IDeviceService.ts
    src/lib/services/mock/device.mock.ts
    src/lib/services/config.ts
    src/lib/services/index.ts
    src/lib/types/entities.ts
    src/app/api/auth/mfa/setup/route.ts
    src/app/api/auth/mfa/verify/route.ts
    src/app/api/auth/devices/route.ts
    src/app/api/auth/devices/[id]/route.ts
    src/auth.ts
    src/auth.config.ts
    src/auth.d.ts
  </files>
  <action>
    **Step 1: Update User entity type**
    Add to User interface in `src/lib/types/entities.ts`:
    ```typescript
    mfaEnabled?: boolean;
    mfaSecret?: string; // Stored encrypted in production, plain in mock
    ```

    **Step 2: Create Device entity type**
    Add to `src/lib/types/entities.ts`:
    ```typescript
    export interface TrustedDevice {
      id: string;
      userId: string;
      deviceToken: string;
      deviceName: string;  // e.g., "Chrome on macOS"
      lastUsed: string;    // ISO 8601
      createdAt: string;
      status: 'active' | 'revoked';
    }
    ```

    **Step 3: Create MFA utilities**
    File: `src/lib/auth/mfa.ts`
    Using the otpauth library (already installed):

    ```typescript
    import * as OTPAuth from 'otpauth';

    export function generateMFASecret(userEmail: string): { secret: string; uri: string } {
      const secret = new OTPAuth.Secret();
      const totp = new OTPAuth.TOTP({
        issuer: 'Elan Glimmora',
        label: userEmail,
        algorithm: 'SHA1',
        digits: 6,
        period: 30,
        secret,
      });
      return {
        secret: secret.base32,
        uri: totp.toString(), // otpauth:// URI for QR code
      };
    }

    export function verifyMFAToken(secret: string, token: string): boolean {
      const totp = new OTPAuth.TOTP({
        algorithm: 'SHA1',
        digits: 6,
        period: 30,
        secret: OTPAuth.Secret.fromBase32(secret),
      });
      // Window of 1 allows 30-second clock drift tolerance
      const delta = totp.validate({ token, window: 1 });
      return delta !== null;
    }
    ```

    **Step 4: Create device recognition utilities**
    File: `src/lib/auth/device-recognition.ts`
    ```typescript
    import { services } from '@/lib/services';

    export function generateDeviceToken(): string {
      // Use crypto API for secure random token
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID() + '-' + Date.now().toString(36);
      }
      return Math.random().toString(36).slice(2) + Date.now().toString(36);
    }

    export function getDeviceName(): string {
      if (typeof navigator === 'undefined') return 'Unknown Device';
      const ua = navigator.userAgent;
      // Simple UA parsing -- detect browser and OS
      let browser = 'Unknown Browser';
      let os = 'Unknown OS';
      if (ua.includes('Chrome')) browser = 'Chrome';
      else if (ua.includes('Firefox')) browser = 'Firefox';
      else if (ua.includes('Safari')) browser = 'Safari';
      if (ua.includes('Mac')) os = 'macOS';
      else if (ua.includes('Windows')) os = 'Windows';
      else if (ua.includes('Linux')) os = 'Linux';
      else if (ua.includes('iPhone') || ua.includes('iPad')) os = 'iOS';
      else if (ua.includes('Android')) os = 'Android';
      return `${browser} on ${os}`;
    }

    export async function registerTrustedDevice(userId: string): Promise<string> {
      const deviceToken = generateDeviceToken();
      const deviceName = getDeviceName();
      await services.device.createDevice({
        userId,
        deviceToken,
        deviceName,
        lastUsed: new Date().toISOString(),
        status: 'active',
      });
      // Store device token in localStorage for client-side reference
      if (typeof window !== 'undefined') {
        localStorage.setItem('elan:device_token', deviceToken);
      }
      return deviceToken;
    }

    export async function isTrustedDevice(userId: string): Promise<boolean> {
      if (typeof window === 'undefined') return false;
      const deviceToken = localStorage.getItem('elan:device_token');
      if (!deviceToken) return false;
      const device = await services.device.getDeviceByToken(deviceToken);
      return device?.userId === userId && device?.status === 'active';
    }
    ```
    NOTE: Using localStorage instead of httpOnly cookies for device tokens since we're in mock-first mode. In production, these would be httpOnly cookies set by the server.

    **Step 5: Create IDeviceService interface**
    File: `src/lib/services/interfaces/IDeviceService.ts`
    ```typescript
    import { TrustedDevice } from '@/lib/types';

    export interface IDeviceService {
      getDevicesByUserId(userId: string): Promise<TrustedDevice[]>;
      getDeviceByToken(token: string): Promise<TrustedDevice | null>;
      createDevice(data: Omit<TrustedDevice, 'id' | 'createdAt'>): Promise<TrustedDevice>;
      revokeDevice(id: string): Promise<TrustedDevice>;
      updateLastUsed(id: string): Promise<void>;
    }
    ```
    Export from interfaces/index.ts barrel.

    **Step 6: Create MockDeviceService**
    File: `src/lib/services/mock/device.mock.ts`
    - Extend BaseMockService
    - localStorage key: 'devices'
    - Implement all IDeviceService methods
    - revokeDevice: set status to 'revoked'
    - updateLastUsed: update lastUsed timestamp

    **Step 7: Update service registry**
    Add `device: IDeviceService` to config.ts and index.ts.

    **Step 8: Create MFA API routes**

    File: `src/app/api/auth/mfa/setup/route.ts`
    - POST handler
    - Require authenticated session via `auth()` from src/auth
    - Call `generateMFASecret(session.user.email)` to get secret and URI
    - Store secret on user via `services.user.updateUser(id, { mfaSecret: secret, mfaEnabled: false })`
    - Return `{ otpauthUri: uri }` (NEVER return secret to client)
    - Error handling: 401 if not authenticated

    File: `src/app/api/auth/mfa/verify/route.ts`
    - POST handler, accepts `{ code: string }`
    - Require authenticated session
    - Get user from service, get their mfaSecret
    - Call `verifyMFAToken(mfaSecret, code)`
    - If valid: update user `{ mfaEnabled: true }`, log audit event, return `{ success: true }`
    - If invalid: return 400 `{ error: 'Invalid verification code' }`

    **Step 9: Create Device management API routes**

    File: `src/app/api/auth/devices/route.ts`
    - GET: Return list of user's trusted devices (filter by session userId)
    - POST: Register new trusted device (call `registerTrustedDevice()`)

    File: `src/app/api/auth/devices/[id]/route.ts`
    - DELETE: Revoke device by ID (verify device belongs to session user)

    **Step 10: Update auth.ts for MFA in login flow (mfaVerified JWT flag approach)**

    This is the committed MFA login verification approach:
    - A `mfaVerified` boolean flag in the JWT controls access to protected routes
    - Middleware redirects MFA-enabled users who haven't verified to /auth/verify-mfa
    - After TOTP verification, the JWT is updated mid-session via `useSession().update()`

    **auth.ts changes:**
    1. In the authorize callback LOGIN path: after successful password verification, if `user.mfaEnabled` is true, set `mfaVerified: false` on the returned user object. If MFA is not enabled, set `mfaVerified: true` (no MFA needed).
    2. In the JWT callback:
       - On sign-in (when `user` is present): copy `user.mfaVerified` (default `true` for non-MFA users) to `token.mfaVerified`
       - On session update trigger: check for `mfaVerified` flag update:
         ```typescript
         jwt({ token, user, trigger, session }) {
           if (user) {
             token.mfaVerified = user.mfaVerified ?? true;
           }
           if (trigger === 'update' && session?.mfaVerified === true) {
             token.mfaVerified = true;
           }
           return token;
         }
         ```
    3. In the session callback: expose `token.mfaVerified` on `session.user.mfaVerified`

    **auth.d.ts changes:**
    Add `mfaVerified?: boolean` to:
    - `next-auth` User interface
    - `next-auth` Session.user
    - `next-auth/jwt` JWT interface

    **Step 11: Update middleware.ts for MFA routing**
    File: `src/middleware.ts` (created in 02-03, updated here)

    Add MFA verification check to the middleware `authorized` callback in `src/auth.config.ts`:
    ```typescript
    authorized({ auth, request }) {
      const isAuthenticated = !!auth?.user;
      const isMfaVerified = auth?.user?.mfaVerified ?? true; // default true for non-MFA users
      const isMfaEnabled = auth?.user?.mfaEnabled ?? false;
      const isVerifyMfaPage = request.nextUrl.pathname === '/auth/verify-mfa';
      const isProtectedRoute = request.nextUrl.pathname.startsWith('/briefing') ||
        request.nextUrl.pathname.startsWith('/portfolio') ||
        request.nextUrl.pathname.startsWith('/dashboard');

      // Allow public routes
      if (!isProtectedRoute && !isVerifyMfaPage) return true;

      // Require authentication for protected routes
      if (!isAuthenticated) return Response.redirect(new URL('/invite', request.nextUrl));

      // MFA check: authenticated but not MFA-verified -> redirect to verify page
      if (isMfaEnabled && !isMfaVerified && !isVerifyMfaPage) {
        return Response.redirect(new URL('/auth/verify-mfa', request.nextUrl));
      }

      // Already MFA-verified but on verify page -> redirect to app
      if (isMfaVerified && isVerifyMfaPage) {
        return Response.redirect(new URL('/briefing', request.nextUrl));
      }

      return true;
    }
    ```

    **NOTE:** The middleware logic lives in `src/auth.config.ts` (edge-compatible), not directly in `src/middleware.ts`. The middleware.ts file just exports the NextAuth middleware using authConfig. The MFA routing logic goes in authConfig's `authorized` callback.
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify TypeScript compilation.
    Run `pnpm build` to verify production build succeeds.
    Verify all files exist:
      - src/lib/auth/mfa.ts, src/lib/auth/device-recognition.ts
      - src/app/api/auth/mfa/setup/route.ts, src/app/api/auth/mfa/verify/route.ts
      - src/app/api/auth/devices/route.ts, src/app/api/auth/devices/[id]/route.ts
      - src/lib/services/mock/device.mock.ts, src/lib/services/interfaces/IDeviceService.ts
    Verify User type has mfaEnabled and mfaSecret fields.
    Verify TrustedDevice type exists in entities.ts.
    Verify auth.d.ts includes `mfaVerified?: boolean` in JWT and Session types.
    Verify auth.config.ts authorized callback checks `mfaEnabled && !mfaVerified` and redirects to /auth/verify-mfa.
    Verify auth.ts jwt callback handles `trigger === 'update'` for mfaVerified flag.
  </verify>
  <done>
    MFA utilities generate TOTP secrets and verify tokens using otpauth library. Device recognition uses localStorage tokens for trusted device tracking. API routes handle MFA setup, verification, and device management. Auth flow updated with committed approach: mfaVerified JWT flag set to false on login for MFA-enabled users, middleware in auth.config.ts redirects to /auth/verify-mfa when mfaEnabled && !mfaVerified, JWT updated mid-session via useSession().update() after TOTP verification. Mock device service stores trusted devices in localStorage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MFA onboarding page, device manager, and context switcher UI</name>
  <files>
    src/app/(marketing)/invite/register/mfa/page.tsx
    src/app/auth/verify-mfa/page.tsx
    src/components/auth/MFASetup.tsx
    src/components/auth/MFAVerify.tsx
    src/components/auth/DeviceManager.tsx
    src/components/auth/ContextSwitcher.tsx
  </files>
  <action>
    **MFASetup component:**
    File: `src/components/auth/MFASetup.tsx`
    'use client' component for the MFA setup flow:

    1. **State:** otpauthUri (string), verificationCode (string), step ('setup' | 'verify' | 'complete'), isLoading, error
    2. **Setup step:**
       - Call `POST /api/auth/mfa/setup` on mount to get otpauthUri
       - Display QR code using a data URL approach:
         - Since we can't install a QR library in this plan, display the otpauth URI as text that users can manually enter in their authenticator app
         - Show the URI in a styled code block: `font-mono text-sm bg-sand-100 p-4 rounded-lg break-all`
         - Label: "Open your authenticator app and add this account manually:"
         - Alternative: Use a simple SVG-based QR approach or instruct to install qrcode library
         - **SIMPLEST:** Display the manual entry key (the secret is in the URI after `secret=`). Parse the URI and display "Manual entry key: XXXX XXXX XXXX XXXX" in groups of 4
         - Actually, do NOT display the secret. Just display instructions to scan. Since we can't generate QR without an image library, show the full otpauth:// URI and tell user to enter it manually in their authenticator app. For v1 mock development, this is acceptable.
       - "Next" button to proceed to verification step

    3. **Verify step:**
       - 6-digit code input (font-mono, text-center, text-2xl, tracking-[0.5em])
       - Auto-focus, numeric keyboard on mobile (inputMode="numeric")
       - Submit: call `POST /api/auth/mfa/verify` with { code }
       - On success: move to complete step
       - On failure: show error "Invalid code, please try again", shake animation

    4. **Complete step:**
       - Success message: "Two-factor authentication is now active" with checkmark icon
       - "Continue to Elan Glimmora" button

    5. **Styling:**
       - Consistent with registration page aesthetic
       - Narrow centered layout (max-w-md)
       - Generous spacing, luxury typography
       - Step indicators (subtle dots or progress bar)

    **MFAVerify component:**
    File: `src/components/auth/MFAVerify.tsx`
    'use client' component for MFA verification during login:

    1. Similar to verify step of MFASetup but standalone
    2. 6-digit TOTP input
    3. Calls `POST /api/auth/mfa/verify`
    4. On success: calls `update({ mfaVerified: true })` from useSession, then redirects
    5. "Use a different device?" link (optional, can be added later)
    6. Subtle trust device checkbox: "Trust this device for 30 days"
       - If checked, call `POST /api/auth/devices` after successful verification

    **MFA onboarding page:**
    File: `src/app/(marketing)/invite/register/mfa/page.tsx`
    - Renders MFASetup component
    - Has "Set up later" link at bottom (skips MFA, redirects to appropriate dashboard)
    - Header: "Secure Your Account" in font-serif, explanatory text about why MFA matters
    - After completion: redirect to /briefing (or context-appropriate route)

    **MFA login verification page:**
    File: `src/app/auth/verify-mfa/page.tsx`
    - Renders MFAVerify component
    - This is where users land when middleware detects `mfaEnabled && !mfaVerified`
    - Header: "Verify Your Identity"
    - Subtext: "Enter the code from your authenticator app"
    - After verification: redirect to intended destination

    **DeviceManager component:**
    File: `src/components/auth/DeviceManager.tsx`
    'use client' component:

    1. Fetches device list from `GET /api/auth/devices`
    2. Displays each device as a card/row:
       - Device name (e.g., "Chrome on macOS")
       - Last used date (formatted nicely)
       - Status indicator (active/revoked)
       - "Revoke" button for active devices
    3. Revoke calls `DELETE /api/auth/devices/[id]`
    4. Confirm dialog before revocation: "This device will need to re-verify with MFA next time."
    5. Empty state: "No trusted devices"
    6. Styling: Clean card-based layout using existing Card component
    7. This component will be used in account settings (future phase) -- for now, make it a standalone component that can be embedded anywhere

    **ContextSwitcher component:**
    File: `src/components/auth/ContextSwitcher.tsx`
    'use client' component:

    1. Import `useAuth` to get current user, context, setContext
    2. Only render if user has roles in multiple domains (e.g., has both b2c and b2b roles)
    3. Display as a minimal dropdown or segmented control:
       - Current context displayed (e.g., "Personal" for b2c, "Institutional" for b2b, "Admin" for admin)
       - Click/select to switch context
       - Use existing Dropdown component or build minimal custom with Radix
    4. On context switch:
       - Call `setContext(newContext)` from useAuth
       - Navigate to the appropriate root route:
         - b2c -> /briefing
         - b2b -> /portfolio
         - admin -> /dashboard
       - Use `useRouter().push()` for navigation
    5. Styling:
       - Small, unobtrusive, fits in navigation bars
       - Icon: small globe or user-switch icon from Lucide
       - Text: font-sans text-xs tracking-wider uppercase
       - Positioned to be placed in B2C top nav, B2B sidebar, or Admin nav

    **Integration points:**
    - MFASetup is used in /invite/register/mfa (onboarding)
    - MFAVerify is used in /auth/verify-mfa (login verification)
    - DeviceManager will be embedded in account settings (future)
    - ContextSwitcher should be added to the B2C, B2B, and Admin layouts where the user has multiple roles
    - For now, just create the ContextSwitcher component -- it will be integrated into existing layouts in this task

    **Update existing layouts:**
    - In B2C layout (src/app/(b2c)/layout.tsx): Add ContextSwitcher in the top nav area
    - In B2B layout (src/app/(b2b)/layout.tsx): Add ContextSwitcher in the sidebar header area
    - In Admin layout (src/app/(admin)/layout.tsx): Add ContextSwitcher in the top nav area
    - ContextSwitcher only renders when user has multiple roles, so it's safe to add everywhere
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify TypeScript compilation.
    Run `pnpm build` to verify production build succeeds.
    Verify all files exist:
      - src/components/auth/MFASetup.tsx (> 60 lines)
      - src/components/auth/MFAVerify.tsx
      - src/components/auth/DeviceManager.tsx (> 60 lines)
      - src/components/auth/ContextSwitcher.tsx (> 40 lines)
      - src/app/(marketing)/invite/register/mfa/page.tsx (> 80 lines)
      - src/app/auth/verify-mfa/page.tsx
    Verify ContextSwitcher is imported in at least one layout file.
  </verify>
  <done>
    MFA setup flow works during onboarding with TOTP code generation and verification. MFA verification page handles login MFA challenge. Device manager component displays trusted devices with revocation. Context switcher enables B2C/B2B/Admin switching for multi-role users. All components use luxury styling consistent with the platform aesthetic.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero errors
2. `pnpm build` succeeds
3. MFA setup page generates TOTP secret and displays for authenticator app enrollment
4. MFA verification accepts valid 6-digit TOTP codes
5. MFA verification rejects invalid codes with error message
6. "Set up later" option skips MFA during onboarding
7. Login with MFA-enabled account redirects to MFA verification
8. Device list shows trusted devices with revoke option
9. Revoking a device removes it from trusted list
10. Context switcher appears for users with multiple roles
11. Context switcher navigates to correct route on domain change
12. All components match luxury aesthetic (not SaaS utility design)
</verification>

<success_criteria>
- MFA setup and verification flow works end-to-end during onboarding
- MFA login verification gates access until TOTP code entered
- Device recognition stores and manages trusted devices
- Context switcher enables B2C/B2B/Admin switching for multi-role users
- All UI components match luxury editorial aesthetic
- All code compiles and builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-marketing-authentication/02-04-SUMMARY.md`
</output>
