---
phase: 01-foundation-design-system
plan: 05
type: execute
wave: 2
depends_on: ["01-04"]
files_modified:
  - src/lib/rbac/permissions.ts
  - src/lib/rbac/usePermission.ts
  - src/lib/rbac/RequirePermission.tsx
  - src/lib/rbac/filters.ts
  - src/lib/rbac/index.ts
  - src/lib/utils/audit.ts
  - src/lib/hooks/useAuth.ts
  - src/components/providers/AuthProvider.tsx
autonomous: true

must_haves:
  truths:
    - "Permission check can('WRITE', 'journey') returns true for UHNI in B2C context and false for Spouse"
    - "Permission check can('APPROVE', 'journey') returns true for ComplianceOfficer in B2B context and false for RelationshipManager"
    - "RequirePermission component renders children when user has permission, renders nothing (or fallback) when user lacks permission"
    - "usePermission hook resolves permissions based on current domain context (B2C vs B2B vs Admin)"
    - "Audit log entries are append-only — no delete method exists on the audit service"
    - "Audit events capture entity, action, user, timestamp, and optional previous/new state"
    - "AuthProvider supplies mock user context with role/permissions to all children"
    - "Super Admin in admin context has FULL access to invite, institution, audit resources"
  artifacts:
    - path: "src/lib/rbac/permissions.ts"
      provides: "Permission matrices for all 11 roles across 3 domains"
      contains: "B2C_PERMISSIONS, B2B_PERMISSIONS, ADMIN_PERMISSIONS"
      min_lines: 80
    - path: "src/lib/rbac/usePermission.ts"
      provides: "Permission resolution hook"
      exports: ["usePermission", "can"]
    - path: "src/lib/rbac/RequirePermission.tsx"
      provides: "Permission gate component"
      exports: ["RequirePermission"]
    - path: "src/lib/rbac/filters.ts"
      provides: "Data filtering by role permissions"
      exports: ["filterByPermission"]
    - path: "src/lib/utils/audit.ts"
      provides: "Immutable audit logging service"
      exports: ["auditService"]
      contains: "append, getAll, getByResource"
    - path: "src/lib/hooks/useAuth.ts"
      provides: "Auth context hook"
      exports: ["useAuth"]
    - path: "src/components/providers/AuthProvider.tsx"
      provides: "Mock auth context provider"
      exports: ["AuthProvider"]
  key_links:
    - from: "src/lib/rbac/usePermission.ts"
      to: "src/lib/rbac/permissions.ts"
      via: "import { getPermissionMatrix }"
      pattern: "getPermissionMatrix"
    - from: "src/lib/rbac/usePermission.ts"
      to: "src/lib/hooks/useAuth.ts"
      via: "import { useAuth }"
      pattern: "useAuth"
    - from: "src/lib/rbac/RequirePermission.tsx"
      to: "src/lib/rbac/usePermission.ts"
      via: "import { usePermission }"
      pattern: "usePermission"
    - from: "src/lib/utils/audit.ts"
      to: "src/lib/types/entities.ts"
      via: "import { AuditEvent }"
      pattern: "AuditEvent"
    - from: "src/components/providers/AuthProvider.tsx"
      to: "src/lib/types/entities.ts"
      via: "import { User, DomainContext }"
      pattern: "import.*User"
---

<objective>
Build the RBAC engine with permission matrices for all 11 roles across 3 domains, and the immutable audit event logging system. These are architectural components that must be in place before any feature development.

Purpose: RBAC controls what every user can see and do. Without it, features cannot enforce access rules and every UI element would need ad-hoc role checks. The audit system ensures all state changes are tracked immutably for compliance. Both are foundational — retrofitting either is far harder than building them first.
Output: RBAC engine (permission matrices, usePermission hook, RequirePermission component, access filters), audit service (append-only logging), and mock auth provider for development.
</objective>

<execution_context>
@/Users/kavi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-design-system/01-RESEARCH.md (Pattern 8: RBAC Engine, Pattern 9: Audit Event System)
@.planning/phases/01-foundation-design-system/01-04-SUMMARY.md (for entity types, role enums, permission types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build RBAC permission matrices, resolution hooks, and gate component</name>
  <files>
    src/lib/rbac/permissions.ts
    src/lib/rbac/usePermission.ts
    src/lib/rbac/RequirePermission.tsx
    src/lib/rbac/filters.ts
    src/lib/rbac/index.ts
    src/lib/hooks/useAuth.ts
    src/components/providers/AuthProvider.tsx
  </files>
  <action>
    1. Create `src/components/providers/AuthProvider.tsx`:
       - 'use client' directive
       - React Context providing: user (User | null), context (DomainContext), setContext, login, logout
       - For Phase 1, this is a MOCK auth provider (real NextAuth comes in Phase 2):
         - Store mock user in React state
         - Provide a way to switch between mock users (dev tool helper)
         - Default mock user: UHNI role in B2C context with id, email, name, roles
         - Expose setContext to switch between 'b2c', 'b2b', 'admin' contexts
       - Export AuthProvider wrapper component
       - Export useAuthContext hook (raw context consumer)

    2. Create `src/lib/hooks/useAuth.ts`:
       - 'use client' directive
       - Thin wrapper around useAuthContext that provides:
         - user: current User object
         - context: current DomainContext ('b2c' | 'b2b' | 'admin')
         - isAuthenticated: boolean
         - currentRole: the user's role for the current context (user.roles[context])
         - setContext: function to switch domain context
       - Throws if used outside AuthProvider

    3. Create `src/lib/rbac/permissions.ts`:
       - Import all role enums from @/lib/types/roles
       - Import Permission, Resource from @/lib/types/permissions

       Define COMPLETE permission matrices for ALL 11 roles:

       **B2C_PERMISSIONS:**
       - UHNI: FULL access (READ, WRITE, DELETE, EXPORT) to journey, vault, intent, privacy, message. CONFIGURE on privacy.
       - Spouse: READ on journey (filtered by sharing), READ on vault (filtered by sharing, not locked). No intent, no privacy.
       - LegacyHeir: READ on journey (filtered), READ on vault (filtered, not locked, not hidden). No intent, no privacy.
       - ElanAdvisor: READ on journey (filtered by visibility scope), READ on intent (summary only), READ+WRITE on message. No vault direct access, no privacy.

       **B2B_PERMISSIONS:**
       - RelationshipManager: READ+WRITE+ASSIGN on client. READ+WRITE on journey. READ+WRITE on risk. READ on vault (governed). READ on audit. READ+WRITE on message.
       - PrivateBanker: READ on client. READ on journey. READ on risk. READ on audit. READ on revenue.
       - FamilyOfficeDirector: READ on client. READ on journey. READ on risk. READ on audit. READ on revenue. CONFIGURE on institution (settings).
       - ComplianceOfficer: READ+APPROVE on journey (approval gatekeeper). READ on client. READ on risk. READ+EXPORT on audit. No vault, no revenue write.
       - InstitutionalAdmin: CONFIGURE on institution. READ+WRITE+ASSIGN on user (within institution). READ+WRITE on contract. READ on audit. CONFIGURE on privacy (retention policy).
       - UHNIPortal: READ on journey (own). READ on client (own profile). No vault, no audit, no risk detail.

       **ADMIN_PERMISSIONS:**
       - SuperAdmin: READ+WRITE+DELETE on invite. READ+WRITE+CONFIGURE on institution. READ on user. READ+EXPORT on audit. READ on revenue. READ on contract. CONFIGURE on user (approve/suspend).

       Export `getPermissionMatrix(context: DomainContext)` function that returns the correct matrix.
       Export `hasPermission(role: Role, action: Permission, resource: Resource, context: DomainContext): boolean` pure function.

    4. Create `src/lib/rbac/usePermission.ts`:
       - 'use client' directive
       - Import useAuth for current user and context
       - Import hasPermission from permissions.ts
       - Export `usePermission(action: Permission, resource: Resource): boolean` hook
         - Gets user and context from useAuth
         - Resolves role from user.roles[context]
         - Calls hasPermission and returns result
       - Export `useCan()` hook that returns a `can(action, resource)` function
         - More ergonomic for multiple checks: `const { can } = useCan(); if (can('WRITE', 'journey')) {...}`

    5. Create `src/lib/rbac/RequirePermission.tsx`:
       - 'use client' directive
       - Props: action (Permission), resource (Resource), fallback? (ReactNode), children (ReactNode)
       - Uses usePermission hook internally
       - Renders children if permission granted, fallback (or null) if denied
       - Does NOT redirect — just hides/shows UI. Route-level protection is handled by middleware (Phase 2).

    6. Create `src/lib/rbac/filters.ts`:
       - Access filtering functions for data arrays:
       - `filterJourneysByAccess(journeys: Journey[], userId: string, role: Role, context: DomainContext): Journey[]`
         - UHNI: returns all own journeys
         - Spouse: returns shared journeys only (not invisible)
         - LegacyHeir: returns shared journeys (not invisible, not locked)
         - ElanAdvisor: returns journeys where advisor has visibility scope
         - B2B roles: returns journeys for assigned clients
       - `filterMemoriesByAccess(memories: MemoryItem[], userId: string, role: Role): MemoryItem[]`
         - UHNI: returns all own memories
         - Spouse: returns memories where 'spouse' in sharingPermissions
         - LegacyHeir: returns memories where 'heir' in sharingPermissions AND not isLocked
         - Others: returns empty array
       - These filters are used by the service layer to enforce data-level access control

    7. Create `src/lib/rbac/index.ts` barrel:
       - Export everything: permissions, usePermission, useCan, RequirePermission, filters
  </action>
  <verify>
    Run `pnpm tsc --noEmit` — all RBAC files compile.
    Verify permission checks:
    - hasPermission(B2CRole.UHNI, Permission.WRITE, 'journey', 'b2c') === true
    - hasPermission(B2CRole.Spouse, Permission.WRITE, 'journey', 'b2c') === false
    - hasPermission(B2BRole.ComplianceOfficer, Permission.APPROVE, 'journey', 'b2b') === true
    - hasPermission(AdminRole.SuperAdmin, Permission.CONFIGURE, 'institution', 'admin') === true
  </verify>
  <done>
    Permission matrices defined for all 11 roles across 3 domains. hasPermission pure function resolves any role/action/resource/context combination. usePermission hook integrates with auth context. RequirePermission component gates UI elements. Access filters available for data-level filtering. Mock AuthProvider supplies development user context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build immutable audit event system</name>
  <files>
    src/lib/utils/audit.ts
  </files>
  <action>
    1. Create `src/lib/utils/audit.ts`:
       - Import AuditEvent type from @/lib/types/entities
       - Import DomainContext from @/lib/types/roles

       Class AuditService:

       **Logging (append-only):**
       - `log(event: Omit<AuditEvent, 'id' | 'timestamp'>): void`
         - Generates id via crypto.randomUUID()
         - Sets timestamp to new Date().toISOString()
         - Appends to localStorage under 'elan:audit' key
         - NEVER modifies existing entries
         - Includes previousState and newState if provided

       **Query methods (read-only):**
       - `getAll(): AuditEvent[]` — returns all events, newest first
       - `getByResource(resourceType: string, resourceId: string): AuditEvent[]`
       - `getByUser(userId: string): AuditEvent[]`
       - `getByContext(context: DomainContext): AuditEvent[]`
       - `getByEvent(eventType: string): AuditEvent[]` — e.g., 'journey.created'
       - `getByDateRange(start: string, end: string): AuditEvent[]`
       - `search(filters: { userId?: string; resourceType?: string; action?: string; context?: DomainContext; startDate?: string; endDate?: string }): AuditEvent[]`

       **GDPR compliance:**
       - `anonymizeUser(userId: string): void`
         - Replaces userId in ALL events with `REDACTED_<uuid>`
         - Adds metadata.anonymized = true, metadata.anonymizedAt = timestamp
         - This is the ONLY mutation allowed on audit data (legal requirement)

       **CRITICAL — No delete method:**
       - Do NOT implement any delete, clear, or remove method
       - Audit logs are immutable and append-only
       - Add a TypeScript comment: `// INTENTIONAL: No delete method. Audit logs are immutable.`

       **SSR safety:**
       - All localStorage operations wrapped in `typeof window !== 'undefined'` check
       - Server-side calls return empty arrays / no-op

       **Export singleton:**
       - Export `const auditService = new AuditService()`

       **Event naming convention (document in comments):**
       - Pattern: `{resource}.{action}` (lowercase)
       - Examples: journey.created, journey.updated, journey.deleted, journey.approved
       - vault.created, vault.locked, vault.erased
       - user.registered, user.suspended, user.erased
       - privacy.updated, privacy.global_erase_requested
       - intent.created, intent.regenerated

    2. Verify the audit service integrates cleanly with the service interfaces from Plan 01-04:
       - IAuditService interface (from Plan 01-04) should match the AuditService class methods
       - If any method signatures don't match, update the audit service to conform to the interface
       - The audit service is both a standalone utility (auditService singleton) and an implementation of IAuditService
  </action>
  <verify>
    Run `pnpm tsc --noEmit` — audit.ts compiles.
    Verify append-only behavior:
    - Call auditService.log({...}) twice
    - Call auditService.getAll() — returns 2 events
    - Verify no delete/clear method exists on the class (TypeScript should prevent calling auditService.delete)
    Verify GDPR:
    - Call auditService.anonymizeUser(userId)
    - Verify events for that userId now have REDACTED prefix
  </verify>
  <done>
    Audit service provides append-only immutable logging. Log method captures event, userId, resourceId, resourceType, context, action, metadata, previousState, newState. Query methods support filtering by resource, user, context, event type, and date range. No delete method exists. GDPR anonymization replaces userId references without deleting events. Singleton exported for use across the application.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes for all RBAC and audit files
2. Permission resolution: UHNI can WRITE journey, Spouse cannot
3. Permission resolution: ComplianceOfficer can APPROVE journey, RM cannot
4. Permission resolution: SuperAdmin can CONFIGURE institution
5. RequirePermission hides UI when permission denied
6. Audit log appends events and never deletes
7. Audit log queries filter correctly (by user, resource, context, event type)
8. GDPR anonymization works without deleting events
9. AuthProvider supplies mock user with switchable domain context
</verification>

<success_criteria>
- Permission matrices cover all 11 roles (4 B2C + 6 B2B + 1 Admin) across all resources
- usePermission hook resolves permissions based on current auth context
- RequirePermission component gates UI element rendering
- Access filter functions available for journey and memory data filtering
- Audit service is append-only with no delete capability
- Audit events track entity/action/user/timestamp/state
- Mock AuthProvider enables development without real auth
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-design-system/01-05-SUMMARY.md`
</output>
