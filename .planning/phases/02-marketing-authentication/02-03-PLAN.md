---
phase: 02-marketing-authentication
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/auth.config.ts
  - src/auth.ts
  - src/auth.d.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/middleware.ts
  - src/lib/auth/invite-codes.ts
  - src/lib/auth/password.ts
  - src/lib/services/mock/invite-code.mock.ts
  - src/lib/services/interfaces/IInviteCodeService.ts
  - src/lib/services/config.ts
  - src/lib/services/index.ts
  - src/components/providers/AuthProvider.tsx
  - src/lib/hooks/useAuth.ts
  - src/app/(marketing)/invite/register/page.tsx
  - src/app/api/invite/validate/route.ts
  - .env.local
autonomous: true

user_setup:
  - service: auth-secret
    why: "NextAuth requires AUTH_SECRET for JWT signing"
    env_vars:
      - name: AUTH_SECRET
        source: "Generate with: openssl rand -base64 32"

must_haves:
  truths:
    - "User can register with valid invite code, email, and password"
    - "User cannot register without a valid invite code"
    - "User cannot register with an expired or used invite code"
    - "User can log in with email and password after registration"
    - "User stays logged in across browser sessions (JWT persistence)"
    - "User can log out from any page"
    - "Protected routes (/briefing, /portfolio, /dashboard) redirect to /invite when not authenticated"
    - "User is assigned roles from invite code on registration"
    - "Invite code is marked as used after successful registration"
  artifacts:
    - path: "src/auth.ts"
      provides: "NextAuth v5 configuration with Credentials provider"
      min_lines: 50
    - path: "src/auth.config.ts"
      provides: "Edge-compatible auth configuration"
      min_lines: 20
    - path: "src/auth.d.ts"
      provides: "NextAuth type extensions for roles"
      min_lines: 15
    - path: "src/middleware.ts"
      provides: "Route protection middleware"
      min_lines: 20
    - path: "src/app/api/auth/[...nextauth]/route.ts"
      provides: "NextAuth API route handlers"
      min_lines: 5
    - path: "src/lib/auth/invite-codes.ts"
      provides: "Invite code validation logic"
      min_lines: 30
    - path: "src/lib/auth/password.ts"
      provides: "Password hashing utilities"
      min_lines: 15
    - path: "src/lib/services/mock/invite-code.mock.ts"
      provides: "Mock invite code service with localStorage"
      min_lines: 60
    - path: "src/app/(marketing)/invite/register/page.tsx"
      provides: "Registration form page"
      min_lines: 100
  key_links:
    - from: "src/auth.ts"
      to: "src/lib/auth/invite-codes.ts"
      via: "validateInviteCode in authorize callback"
      pattern: "validateInviteCode|authorize"
    - from: "src/auth.ts"
      to: "src/lib/auth/password.ts"
      via: "hashPassword and verifyPassword in authorize"
      pattern: "hashPassword|verifyPassword"
    - from: "src/auth.ts"
      to: "src/lib/services"
      via: "service calls for user creation and invite code update"
      pattern: "services\\.user|services\\.inviteCode"
    - from: "src/middleware.ts"
      to: "src/auth.config.ts"
      via: "edge-compatible auth config import"
      pattern: "import.*authConfig|import.*auth\\.config"
    - from: "src/app/(marketing)/invite/register/page.tsx"
      to: "next-auth/react"
      via: "signIn function call for registration"
      pattern: "signIn.*credentials"
    - from: "src/auth.ts"
      to: "jwt and session callbacks"
      via: "role assignment in callbacks"
      pattern: "token\\.roles|session\\.user\\.roles"
---

<objective>
Integrate NextAuth v5 with JWT sessions, Credentials provider, invite code validation, and protected route middleware.

Purpose: Establish the complete authentication infrastructure for invite-only registration and login. This is the security backbone of the UHNI platform -- invite codes gate access, JWT sessions persist across browser sessions, and middleware protects authenticated routes.

Output: Working auth system with registration, login, logout, session persistence, route protection, invite code validation, and role assignment on registration.
</objective>

<execution_context>
@/Users/kavi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kavi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-marketing-authentication/02-RESEARCH.md
@.planning/phases/01-foundation-design-system/01-04-SUMMARY.md
@.planning/phases/01-foundation-design-system/01-05-SUMMARY.md

Key existing infrastructure:
- User entity type at src/lib/types/entities.ts (id, email, name, roles, etc.)
- UserRoles type at src/lib/types/roles.ts (b2c?, b2b?, admin?)
- InviteCode entity at src/lib/types/entities.ts (code, type, assignedRoles, maxUses, usedCount, expiresAt, status)
- IUserService interface at src/lib/services/interfaces/IUserService.ts
- MockUserService at src/lib/services/mock/user.mock.ts (has createUser, getUserByEmail)
- Service registry at src/lib/services/config.ts (currently 6 services)
- Mock AuthProvider at src/components/providers/AuthProvider.tsx (to be replaced/upgraded)
- useAuth hook at src/lib/hooks/useAuth.ts (to be replaced/upgraded)
- RBAC engine at src/lib/rbac/ (permissions.ts, usePermission.ts, etc.)
- Audit service at src/lib/utils/audit.ts
- Zod validation schemas at src/lib/types/validation.ts (includes CreateInviteCodeSchema)
- react-hook-form + @hookform/resolvers in package.json
- NO NextAuth currently installed -- must install next-auth@beta, jose, bcryptjs, @types/bcryptjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install NextAuth v5 and create auth infrastructure</name>
  <files>
    .env.local
    src/auth.config.ts
    src/auth.ts
    src/auth.d.ts
    src/app/api/auth/[...nextauth]/route.ts
    src/app/api/invite/validate/route.ts
    src/middleware.ts
    src/lib/auth/password.ts
    src/lib/auth/invite-codes.ts
    src/lib/services/interfaces/IInviteCodeService.ts
    src/lib/services/mock/invite-code.mock.ts
    src/lib/services/config.ts
    src/lib/services/index.ts
  </files>
  <action>
    **Step 1: Install dependencies**
    ```bash
    cd /Users/kavi/Baarez-Projects/E-Glimmora
    pnpm add next-auth@beta jose otpauth bcryptjs
    pnpm add -D @types/bcryptjs
    ```

    **Step 2: Create .env.local**
    ```
    AUTH_SECRET=development-secret-change-in-production-min-32-chars!!
    NEXTAUTH_URL=http://localhost:3000
    ```
    Generate a real secret with `openssl rand -base64 32` and replace the placeholder.

    **Step 3: Create IInviteCodeService interface**
    File: `src/lib/services/interfaces/IInviteCodeService.ts`
    ```typescript
    import { InviteCode, CreateInviteCodeInput } from '@/lib/types';

    export interface IInviteCodeService {
      getInviteCodes(): Promise<InviteCode[]>;
      getInviteCodeById(id: string): Promise<InviteCode | null>;
      getInviteCodeByCode(code: string): Promise<InviteCode | null>;
      createInviteCode(data: CreateInviteCodeInput): Promise<InviteCode>;
      updateInviteCode(id: string, data: Partial<InviteCode>): Promise<InviteCode>;
      markAsUsed(id: string, usedByUserId: string): Promise<InviteCode>;
    }
    ```
    Also export this interface from `src/lib/services/interfaces/index.ts` barrel.

    **Step 4: Create MockInviteCodeService**
    File: `src/lib/services/mock/invite-code.mock.ts`
    - Extend BaseMockService
    - localStorage key: 'invite_codes'
    - Implement all IInviteCodeService methods
    - `getInviteCodeByCode`: search by `code` field
    - `markAsUsed`: increment `usedCount`, set status to 'used' if usedCount >= maxUses, set updatedAt
    - **Seed 3 default invite codes on initialization** (if localStorage is empty):
      1. `{ code: 'ELAN-TEST-B2CC-CODE', type: 'b2c', assignedRoles: { b2c: 'UHNI' }, maxUses: 1, usedCount: 0, status: 'active' }`
      2. `{ code: 'ELAN-TEST-B2BB-CODE', type: 'b2b', assignedRoles: { b2b: 'RelationshipManager' }, maxUses: 1, usedCount: 0, status: 'active' }`
      3. `{ code: 'ELAN-TEST-ADMN-CODE', type: 'admin', assignedRoles: { admin: 'SuperAdmin' }, maxUses: 1, usedCount: 0, status: 'active' }`
    - These test codes allow development without manual invite code creation

    **Step 5: Update service registry**
    File: `src/lib/services/config.ts`
    - Import IInviteCodeService and MockInviteCodeService
    - Add `inviteCode` to the services object
    - Update type assertion to include `inviteCode: IInviteCodeService`

    Also update `src/lib/services/index.ts` to re-export IInviteCodeService.

    **Step 6: Create password utilities**
    File: `src/lib/auth/password.ts`
    ```typescript
    import bcrypt from 'bcryptjs';

    const SALT_ROUNDS = 12;

    export async function hashPassword(password: string): Promise<string> {
      return bcrypt.hash(password, SALT_ROUNDS);
    }

    export async function verifyPassword(password: string, hash: string): Promise<boolean> {
      return bcrypt.compare(password, hash);
    }
    ```

    **Step 7: Create invite code validation**
    File: `src/lib/auth/invite-codes.ts`
    ```typescript
    import { services } from '@/lib/services';
    import type { InviteCode } from '@/lib/types';

    export async function validateInviteCode(code: string): Promise<{ valid: boolean; error?: string; inviteCode?: InviteCode }> {
      const inviteCode = await services.inviteCode.getInviteCodeByCode(code);

      if (!inviteCode) {
        return { valid: false, error: 'Invalid invite code' };
      }

      if (inviteCode.status !== 'active') {
        return { valid: false, error: 'This invite code has already been used or expired' };
      }

      if (inviteCode.usedCount >= inviteCode.maxUses) {
        return { valid: false, error: 'This invite code has reached its usage limit' };
      }

      if (inviteCode.expiresAt && new Date(inviteCode.expiresAt) < new Date()) {
        return { valid: false, error: 'This invite code has expired' };
      }

      return { valid: true, inviteCode };
    }
    ```

    **Step 8: Upgrade /api/invite/validate route for backend validation**
    File: `src/app/api/invite/validate/route.ts` (created as format-only stub in 02-01)
    - Replace the format-only stub with real backend validation
    - POST handler accepting `{ code: string }`
    - Import `validateInviteCode` from `@/lib/auth/invite-codes`
    - Call `validateInviteCode(code)` which checks the mock invite code service for existence, status (active), usage limits (usedCount < maxUses), and expiry
    - Return `{ valid: true }` if valid, `{ valid: false, error: string }` with specific error messages for each failure case (invalid code, already used, expired)
    - Return 200 for valid, 400 for invalid format, 422 for invalid/expired/used codes
    - This ensures the invite page (from 02-01) now validates against the real backend, not just format

    **Step 9: Create NextAuth type declarations**
    File: `src/auth.d.ts`
    Extend NextAuth types to include roles:
    ```typescript
    import { UserRoles } from '@/lib/types/roles';

    declare module "next-auth" {
      interface User {
        roles?: UserRoles;
        passwordHash?: string;
        mfaEnabled?: boolean;
        mfaSecret?: string;
      }
      interface Session {
        user: {
          id: string;
          email: string;
          name: string;
          roles: UserRoles;
          mfaEnabled?: boolean;
        } & DefaultSession["user"];
      }
    }

    declare module "next-auth/jwt" {
      interface JWT {
        userId: string;
        roles: UserRoles;
        mfaEnabled?: boolean;
      }
    }
    ```

    **Step 10: Create auth.config.ts (edge-compatible)**
    File: `src/auth.config.ts`
    - Define pages: signIn -> '/invite'
    - Define authorized callback:
      - Allow all public routes (/, /philosophy, /privacy, /invite, /invite/register)
      - Require auth for protected routes (/briefing/*, /portfolio/*, /dashboard/*)
      - Redirect unauthenticated users to /invite
    - Empty providers array (providers in auth.ts)

    **Step 11: Create auth.ts (full configuration)**
    File: `src/auth.ts`
    - Import authConfig and spread it
    - Session strategy: "jwt"
    - Session maxAge: 30 days (30 * 24 * 60 * 60)
    - Credentials provider with:
      - credentials: { email: {}, password: {}, inviteCode: {}, isRegistration: {} }
      - authorize callback:
        - Parse and validate input with Zod
        - If `isRegistration === 'true'` AND `inviteCode` present:
          - Validate invite code via `validateInviteCode()`
          - **If invite code invalid/expired/used: throw new Error('INVITE_INVALID: <specific reason>') -- e.g., 'INVITE_INVALID: This invite code has already been used', 'INVITE_INVALID: This invite code has expired', 'INVITE_INVALID: Invalid invite code'**
          - Check if email already exists via `services.user.getUserByEmail()` -- if exists, throw new Error('EMAIL_EXISTS: An account with this email already exists')
          - Hash password
          - Create user via `services.user.createUser()` with roles from invite code
          - Mark invite code as used via `services.inviteCode.markAsUsed()`
          - Log audit event (user.registered)
          - Return user object
        - Else (LOGIN path):
          - Get user by email
          - Verify password
          - If valid, return user
          - If invalid, return null
        - **Error surfacing:** NextAuth v5 with `redirect: false` returns `{ error: string }` from the authorize callback's thrown error message. The registration page uses these prefixed error strings (INVITE_INVALID, EMAIL_EXISTS) to display specific, user-friendly error messages.
    - JWT callback:
      - On sign in (user exists): copy user.id, user.roles to token
      - On subsequent requests: token passes through unchanged
    - Session callback:
      - Copy token.userId, token.roles, token.mfaEnabled to session.user
    - Export: `auth`, `signIn`, `signOut`, `handlers`

    **IMPORTANT:** The authorize callback in Credentials provider runs server-side. Since we use mock services with localStorage, and localStorage is NOT available server-side, the mock services must handle SSR gracefully. The existing BaseMockService already checks `typeof window !== 'undefined'`. For auth to work:
    - The registration and login API routes run in Node.js (NOT Edge), so they CAN access localStorage in development via the mock service pattern
    - HOWEVER: In a proper implementation, auth flows should work without localStorage. Since this is mock-first development, the mock services will need to work in the API route context.
    - Solution: The mock services' localStorage calls are client-side only. For server-side auth, we need the mock invite code service to have an in-memory fallback for the seeded test codes. Add a `getSeededCodes()` method that returns the 3 test codes without localStorage.

    **Step 12: Create API route handler**
    File: `src/app/api/auth/[...nextauth]/route.ts`
    ```typescript
    import { handlers } from "@/auth";
    export const { GET, POST } = handlers;
    ```

    **Step 13: Create middleware**
    File: `src/middleware.ts`
    ```typescript
    import NextAuth from "next-auth";
    import { authConfig } from "./auth.config";

    export default NextAuth(authConfig).auth;

    export const config = {
      matcher: [
        '/((?!api|_next/static|_next/image|favicon.ico).*)',
      ],
    };
    ```
    NOTE: Middleware uses `authConfig` (edge-compatible), NOT `auth` from auth.ts.

    **Step 14: Update MockUserService**
    The existing MockUserService needs a `passwordHash` field on User creation. Currently User type doesn't have passwordHash. Since we're using mock services:
    - Add `passwordHash?: string` to the User entity in entities.ts (optional field, only used internally)
    - Update createUser in mock service to accept and store passwordHash
    - The User type extension in auth.d.ts already adds `passwordHash` to the NextAuth User type
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify TypeScript compilation.
    Run `pnpm build` to verify production build succeeds.
    Verify all files exist:
      - src/auth.ts, src/auth.config.ts, src/auth.d.ts
      - src/app/api/auth/[...nextauth]/route.ts
      - src/app/api/invite/validate/route.ts
      - src/middleware.ts
      - src/lib/auth/password.ts, src/lib/auth/invite-codes.ts
      - src/lib/services/mock/invite-code.mock.ts
      - src/lib/services/interfaces/IInviteCodeService.ts
    Verify next-auth is in package.json dependencies.
    Verify .env.local exists with AUTH_SECRET.
    Verify /api/invite/validate route imports and calls validateInviteCode from src/lib/auth/invite-codes.ts.
  </verify>
  <done>
    NextAuth v5 is configured with Credentials provider, JWT sessions (30-day), invite code validation in authorize callback, role assignment from invite codes, edge-compatible middleware protecting authenticated routes, password hashing with bcryptjs, and mock invite code service with 3 seeded test codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create registration page and update AuthProvider for NextAuth</name>
  <files>
    src/app/(marketing)/invite/register/page.tsx
    src/components/providers/AuthProvider.tsx
    src/lib/hooks/useAuth.ts
  </files>
  <action>
    **Registration page at /invite/register:**

    1. 'use client' component
    2. Export metadata via generateMetadata or layout (since 'use client', handle via parent layout or skip)
    3. Full-screen luxury layout matching the invite page aesthetic

    **Page flow:**
    - Check for invite code in sessionStorage (stored by invite page from 02-01)
    - If no invite code, redirect to /invite with message

    **Registration form:**
    - Use react-hook-form with zodResolver
    - Zod schema:
      ```
      z.object({
        email: z.string().email('Please enter a valid email address'),
        name: z.string().min(2, 'Name must be at least 2 characters').max(100),
        password: z.string()
          .min(12, 'Password must be at least 12 characters')
          .regex(/[A-Z]/, 'Must contain an uppercase letter')
          .regex(/[a-z]/, 'Must contain a lowercase letter')
          .regex(/[0-9]/, 'Must contain a number'),
        confirmPassword: z.string(),
      }).refine(data => data.password === data.confirmPassword, {
        message: "Passwords don't match",
        path: ['confirmPassword'],
      })
      ```

    **Form fields (styled with existing Input component):**
    1. Full name input -- icon: User (Lucide)
    2. Email input -- icon: Mail (Lucide)
    3. Password input -- icon: Lock (Lucide), with show/hide toggle
    4. Confirm password input -- icon: Lock (Lucide)
    5. Submit button: "Create Account" -- full width, bg-rose-900, loading state

    **Form layout:**
    - Narrow centered card (max-w-md)
    - Background: subtle sand-50 or white
    - Header:
      - Eyebrow: "EXCLUSIVE MEMBERSHIP" in text-xs tracking-widest text-sand-400
      - Heading: "Create Your Account" in font-serif text-3xl text-rose-900
      - Display the invite code in a subtle badge: "Invited with: ELAN-XXXX-..." truncated
    - Form fields with generous spacing (space-y-5)
    - Password requirements displayed below password field as subtle text (text-xs text-sand-400)
    - Error messages in text-rose-600 text-sm

    **Submission flow:**
    1. **Pre-validate invite code:** Before calling signIn, call `POST /api/invite/validate` with the invite code from sessionStorage to re-validate it against the backend. This prevents stale or manually-injected sessionStorage codes from reaching the authorize callback. If validation fails, display the error and redirect back to /invite.
    2. Call `signIn('credentials', { email, password, inviteCode, isRegistration: 'true', redirect: false })`
    3. **Error handling with specific messages:** Parse the error response from signIn:
       - If error contains 'INVITE_INVALID': display the specific invite code error (expired, used, invalid) and offer a link back to /invite to enter a new code
       - If error contains 'EMAIL_EXISTS': display "An account with this email already exists" with a link to login
       - For other errors: display generic "Registration failed. Please try again."
       - All errors shown with subtle shake animation (framer-motion x: [-10, 10, -10, 10, 0])
    4. On success: show brief success message, then redirect to /briefing (B2C) or appropriate context based on invite type
       - For v1, redirect to /briefing for b2c, /portfolio for b2b, /dashboard for admin
       - Retrieve invite code type from sessionStorage to determine redirect target

    **Page animations:**
    - ScrollReveal for form entrance (fadeUp)
    - Error shake animation using framer-motion (x: [-10, 10, -10, 10, 0])
    - Loading state: Button shows subtle spinner

    **Update AuthProvider.tsx:**
    Replace the mock AuthProvider with a NextAuth SessionProvider wrapper:

    ```typescript
    'use client';
    import { SessionProvider } from 'next-auth/react';
    import { ReactNode } from 'react';

    interface AuthProviderProps {
      children: ReactNode;
    }

    export function AuthProvider({ children }: AuthProviderProps) {
      return <SessionProvider>{children}</SessionProvider>;
    }
    ```

    **IMPORTANT:** The old mock AuthProvider had setMockUser, setContext, login/logout methods. These are no longer needed since NextAuth manages sessions. However, we need to preserve context switching (B2C/B2B). Create a new ContextProvider or add context state to AuthProvider:

    ```typescript
    'use client';
    import { SessionProvider, useSession } from 'next-auth/react';
    import { ReactNode, createContext, useContext, useState } from 'react';
    import { DomainContext } from '@/lib/types';

    interface DomainContextValue {
      context: DomainContext;
      setContext: (context: DomainContext) => void;
    }

    const DomainCtx = createContext<DomainContextValue | undefined>(undefined);

    function DomainContextProvider({ children }: { children: ReactNode }) {
      const [context, setContext] = useState<DomainContext>('b2c');
      return (
        <DomainCtx.Provider value={{ context, setContext }}>
          {children}
        </DomainCtx.Provider>
      );
    }

    export function useDomainContext() {
      const ctx = useContext(DomainCtx);
      if (!ctx) throw new Error('useDomainContext must be used within AuthProvider');
      return ctx;
    }

    export function AuthProvider({ children }: { children: ReactNode }) {
      return (
        <SessionProvider>
          <DomainContextProvider>
            {children}
          </DomainContextProvider>
        </SessionProvider>
      );
    }
    ```

    **Update useAuth.ts:**
    Replace mock auth hook with NextAuth-based hook:

    ```typescript
    'use client';
    import { useSession, signOut } from 'next-auth/react';
    import { useDomainContext } from '@/components/providers/AuthProvider';
    import { UserRoles, DomainContext, Role } from '@/lib/types';

    export function useAuth() {
      const { data: session, status } = useSession();
      const { context, setContext } = useDomainContext();

      const user = session?.user ?? null;
      const isAuthenticated = status === 'authenticated';
      const isLoading = status === 'loading';

      const currentRole: Role | null = user?.roles
        ? (user.roles[context as keyof UserRoles] as Role) ?? null
        : null;

      const logout = async () => {
        await signOut({ callbackUrl: '/' });
      };

      return {
        user,
        context,
        setContext,
        isAuthenticated,
        isLoading,
        currentRole,
        logout,
      };
    }
    ```

    **CRITICAL:** Make sure the root layout at src/app/layout.tsx wraps children with AuthProvider. Check if it already does -- if not, add it. The marketing layout does NOT need auth wrapping for public pages, but the AuthProvider should be at root level so `useSession` works everywhere.

    Check if root layout already has AuthProvider. If yes, good. If not, add it:
    ```tsx
    // src/app/layout.tsx
    import { AuthProvider } from '@/components/providers/AuthProvider';

    export default function RootLayout({ children }) {
      return (
        <html>
          <body>
            <AuthProvider>
              {children}
            </AuthProvider>
          </body>
        </html>
      );
    }
    ```
  </action>
  <verify>
    Run `pnpm tsc --noEmit` to verify TypeScript compilation.
    Run `pnpm build` to verify production build succeeds.
    Verify registration page exists at src/app/(marketing)/invite/register/page.tsx.
    Verify registration page calls `/api/invite/validate` before signIn (grep for 'api/invite/validate' in the file).
    Verify registration page handles INVITE_INVALID and EMAIL_EXISTS error prefixes from signIn response.
    Verify AuthProvider.tsx uses SessionProvider from next-auth/react.
    Verify useAuth.ts uses useSession from next-auth/react.
    Verify root layout wraps children in AuthProvider.
  </verify>
  <done>
    Registration page at /invite/register has luxury form with email, name, password fields, Zod validation, and signIn integration. Registration page re-validates invite code from sessionStorage against /api/invite/validate before calling signIn, preventing bypass. Error responses from authorize callback (INVITE_INVALID, EMAIL_EXISTS) are parsed and displayed as specific user-friendly messages. AuthProvider upgraded from mock to NextAuth SessionProvider with domain context support. useAuth hook uses NextAuth session with role resolution. Root layout wraps children in AuthProvider.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero errors
2. `pnpm build` succeeds
3. NextAuth API routes respond at /api/auth/*
4. Registration with valid test invite code creates user and assigns roles
5. Registration with invalid/used invite code fails with error message
6. Login with registered email/password succeeds
7. Protected routes (/briefing, /portfolio, /dashboard) redirect to /invite when not logged in
8. Session persists across page refresh (JWT)
9. Logout clears session and redirects to homepage
10. useAuth hook returns session data and role information
</verification>

<success_criteria>
- Complete NextAuth v5 auth infrastructure with JWT sessions
- Invite-only registration gates access behind valid invite codes
- Password hashing with bcryptjs (12 salt rounds)
- Protected route middleware redirects unauthenticated users
- Role assignment from invite codes persisted in JWT
- Registration page with luxury UX and form validation
- AuthProvider upgraded from mock to NextAuth SessionProvider
- Mock invite code service with 3 seeded test codes for development
</success_criteria>

<output>
After completion, create `.planning/phases/02-marketing-authentication/02-03-SUMMARY.md`
</output>
